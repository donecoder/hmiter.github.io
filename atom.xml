<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>黄敏</title>
  <icon>https://www.gravatar.com/avatar/ce5b59858047484c6bb4b99b631fb3e9</icon>
  <subtitle>黄敏的博客!</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://mindasoft.com/"/>
  <updated>2018-12-05T06:51:17.969Z</updated>
  <id>http://mindasoft.com/</id>
  
  <author>
    <name>Huang min</name>
    <email>hmiter@sina.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaSE源码分析-TreeSet源码剖析</title>
    <link href="http://mindasoft.com/2018/12/05/javase/TreeSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/12/05/javase/TreeSet源码剖析/</id>
    <published>2018-12-05T03:00:37.000Z</published>
    <updated>2018-12-05T06:51:17.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeSet简介"><a href="#TreeSet简介" class="headerlink" title="TreeSet简介"></a>TreeSet简介</h1><p>TreeSet是基于TreeMap实现的，元素的顺序取决于元素自身的自然顺序或者在构造时提供的比较器。</p><ul><li>TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。</li><li>对于add，remove，contains操作，保证log（n）的时间复杂度。</li><li>因为Set接口的定义根据equals方法，但是TreeSet接口约定元素的顺序基于compareTo或者compare方法，所以它们要保持一致性才能保证程序不会出错。</li><li>TreeSet是<strong>不同步</strong>的，运行在多线程环境下需要外部同步化或调用</li><li>它的iterator 方法返回的迭代器是fail-fast的。<figure class="highlight ebnf hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">SortedSet s</span> = Collections.synchronizedSortedSet(new TreeSet(...));</span><br></pre></td></tr></table></figure></li></ul><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSet&lt;E&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet&lt;E&gt;</span></span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-title">implements</span> <span class="hljs-title">NavigableSet&lt;E&gt;</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>它继承于AbstractSet抽象类，实现了NavigableSet<e>, Cloneable, java.io.Serializable接口。</e></p><p>TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。</p><p>TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。</p><p>TreeSet 实现了Cloneable接口，意味着它能被克隆。</p><p>TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。</p><h1 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h1><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * The backing map.</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E,<span class="hljs-keyword">Object</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span> PRESENT = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Object</span>();</span><br></pre></td></tr></table></figure><p> TreeSet包含了两个重要的成员变量：m, PRESENT。</p><ol><li>m是一个NavigableMap<e, object="">对象，TreeSet是由一个NavigableMa实例支持的。</e,></li><li>PRESENT是一个static final Object对象，用来作为NavigableMap中的value值。</li></ol><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//这个构造器不是导出API,在下面构造器有使用这个构造器</span></span><br><span class="line">TreeSet(NavigableMap&lt;E,Object&gt; m) &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.m = m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//调用第一个的构造器,创建一个空的TreeSet,不提供比较器,使用元素自然顺序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//调用第一个构造器,提供比较器,比较器由TreeMap维护,TreeSet本身没有比较器</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;&gt;(comparator));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//通过Collection的子类构造TreeSet,不提供比较器,使用元素的自然顺序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//通过SortedSet的子类构造TreeSet,SortedSet本身可能有比较器,如果有,使用该比较器,否则使用元素自然顺序</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">(SortedSet&lt;E&gt; s)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(s.comparator());</span><br><span class="line">    addAll(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="add-和addAll"><a href="#add-和addAll" class="headerlink" title="add 和addAll"></a>add 和addAll</h1><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> m.put(e, PRESENT)==<span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span>  <span class="hljs-built_in">boolean</span> addAll(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    <span class="hljs-comment">// Use linear-time version if applicable</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (m.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span> &amp;&amp; c.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span> &amp;&amp;</span><br><span class="line">        c <span class="hljs-keyword">instanceof</span> SortedSet &amp;&amp;</span><br><span class="line">        m <span class="hljs-keyword">instanceof</span> TreeMap) &#123;</span><br><span class="line">        SortedSet&lt;? extends E&gt; <span class="hljs-built_in">set</span> = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">        TreeMap&lt;E,<span class="hljs-keyword">Object</span>&gt; <span class="hljs-built_in">map</span> = (TreeMap&lt;E, <span class="hljs-keyword">Object</span>&gt;) m;</span><br><span class="line">        Comparator&lt;?&gt; cc = <span class="hljs-built_in">set</span>.comparator();</span><br><span class="line">        Comparator&lt;? <span class="hljs-keyword">super</span> E&gt; mc = <span class="hljs-built_in">map</span>.comparator();</span><br><span class="line">        </span><br><span class="line">        <span class="hljs-comment">// 如果两个Comparator 相等，那么添加到map里面</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (cc==mc || (cc != <span class="hljs-keyword">null</span> &amp;&amp; cc.equals(mc))) &#123;</span><br><span class="line">            <span class="hljs-built_in">map</span>.addAllForTreeSet(<span class="hljs-built_in">set</span>, PRESENT);</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>add 调用的是的map.put方法。由构造方法来看，其实是调用了TreeMap的put()方法（TreeMap的put重写了NavigableSet的put）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TreeSet简介&quot;&gt;&lt;a href=&quot;#TreeSet简介&quot; class=&quot;headerlink&quot; title=&quot;TreeSet简介&quot;&gt;&lt;/a&gt;TreeSet简介&lt;/h1&gt;&lt;p&gt;TreeSet是基于TreeMap实现的，元素的顺序取决于元素自身的自然顺序或者在构
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="TreeSet" scheme="http://mindasoft.com/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-TreeMap源码剖析</title>
    <link href="http://mindasoft.com/2018/12/05/javase/TreeMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/12/05/javase/TreeMap源码剖析/</id>
    <published>2018-12-05T03:00:37.000Z</published>
    <updated>2018-12-05T07:05:22.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h1><p>TreeMap的基本概念：</p><p>TreeMap集合是基于红黑树（Red-Black tree）的 NavigableMap实现。该集合最重要的特点就是可排序，该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。这句话是什么意思呢？就是说TreeMap可以对添加进来的元素进行排序，可以按照默认的排序方式，也可以自己指定排序方式。</p><h1 id="类定义及类成员变量"><a href="#类定义及类成员变量" class="headerlink" title="类定义及类成员变量"></a>类定义及类成员变量</h1><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">NavigableMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 比较器对象</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; comparator;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 根节点</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 集合大小</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 树结构被修改的次数</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 静态内部类用来表示节点类型</span></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">        K key;     <span class="hljs-comment">// 键</span></span><br><span class="line">        V value;   <span class="hljs-comment">// 值</span></span><br><span class="line">        Entry&lt;K,V&gt; left;    <span class="hljs-comment">// 指向左子树的引用（指针）</span></span><br><span class="line">        Entry&lt;K,V&gt; right;   <span class="hljs-comment">// 指向右子树的引用（指针）</span></span><br><span class="line">        Entry&lt;K,V&gt; parent;  <span class="hljs-comment">// 指向父节点的引用（指针）</span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> color = BLACK; <span class="hljs-comment">// 当前节点颜色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类构造方法"><a href="#类构造方法" class="headerlink" title="类构造方法"></a>类构造方法</h1><p>先来看下TreeMap的构造方法。TreeMap一共有4个构造方法。</p><p><strong>无参构造方法</strong><br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    comparator = <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>采用无参构造方法，不指定比较器，这时候，排序的实现要依赖key.compareTo()方法，因此key必须实现Comparable接口，并覆写其中的compareTo方法。</p><p><strong>带有比较器的构造方法</strong></p><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeMap</span><span class="hljs-params">(Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; comparator)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.comparator = comparator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用带比较器的构造方法，这时候，排序依赖该比较器，key可以不用实现Comparable接口。</p><p><strong>带Map的构造方法</strong><br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = <span class="hljs-keyword">null</span>;</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该构造方法同样不指定比较器，调用putAll方法将Map中的所有元素加入到TreeMap中。putAll的源码如下：<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 将map中的全部节点添加到TreeMap中</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> putAll(Map&lt;? extends K, ? extends V&gt; <span class="hljs-built_in">map</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// 获取map的大小</span></span><br><span class="line">    <span class="hljs-built_in">int</span> mapSize = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>();</span><br><span class="line">    <span class="hljs-comment">// 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对”</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span>==<span class="hljs-number">0</span> &amp;&amp; mapSize!=<span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">map</span> <span class="hljs-keyword">instanceof</span> SortedMap) &#123;</span><br><span class="line">        Comparator c = ((SortedMap)<span class="hljs-built_in">map</span>).comparator();</span><br><span class="line">        <span class="hljs-comment">// 如果TreeMap和map的比较器相等；</span></span><br><span class="line">        <span class="hljs-comment">// 则将map的元素全部拷贝到TreeMap中，然后返回！</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (c == comparator || (c != <span class="hljs-keyword">null</span> &amp;&amp; c.equals(comparator))) &#123;</span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                buildFromSorted(mapSize, <span class="hljs-built_in">map</span>.entrySet().iterator(),</span><br><span class="line">                        <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (java._01_io.IOException cannotHappen) &#123;</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// 调用AbstractMap中的putAll();</span></span><br><span class="line">    <span class="hljs-comment">// AbstractMap中的putAll()又会调用到TreeMap的put()</span></span><br><span class="line">    <span class="hljs-keyword">super</span>.putAll(<span class="hljs-built_in">map</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>显然，如果Map里的元素是排好序的，就调用buildFromSorted方法来拷贝Map中的元素，这在下一个构造方法中会重点提及，而如果Map中的元素不是排好序的，就调用AbstractMap的putAll(map)方法，该方法源码如下：<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet())</span><br><span class="line">        put(e.getKey(), e.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很明显它是将Map中的元素一个个put（插入）到TreeMap中的，主要因为Map中的元素是无序存放的，因此要一个个插入到红黑树中，使其有序存放，并满足红黑树的性质。<br><strong>带有SortedMap的构造方法</strong><br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeMap</span><span class="hljs-params">(SortedMap&lt;K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    comparator = m.comparator();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        buildFromSorted(m.size(), m.entrySet().iterator(), <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (java._01_io.IOException cannotHappen) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException cannotHappen) &#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先将比较器指定为m的比较器，这取决于生成m时调用构造方法是否传入了指定的构造器，而后调用buildFromSorted方法，将SortedMap中的元素插入到TreeMap中，由于SortedMap中的元素师有序的，实际上它是根据SortedMap创建的TreeMap，将SortedMap中对应的元素添加到TreeMap中。</p><h1 id="put-方法详解"><a href="#put-方法详解" class="headerlink" title="put()方法详解"></a>put()方法详解</h1><p>插入操作即对应TreeMap的put方法，put操作实际上只需按照二叉排序树的插入步骤来操作即可，插入到指定位置后，再做调整，使其保持红黑树的特性。put源码的实现：<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;  <span class="hljs-comment">// 获取根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果根节点为空，则该元素置为根节点 </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        compare(<span class="hljs-built_in">key</span>, <span class="hljs-built_in">key</span>); <span class="hljs-comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="hljs-keyword">new</span> Entry&lt;&gt;(<span class="hljs-built_in">key</span>, value, <span class="hljs-keyword">null</span>);</span><br><span class="line">        <span class="hljs-built_in">size</span> = <span class="hljs-number">1</span>;    <span class="hljs-comment">// 集合大小为1</span></span><br><span class="line">        modCount++;  <span class="hljs-comment">// 结构修改次数自增</span></span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    Comparator&lt;? <span class="hljs-keyword">super</span> K&gt; cpr = comparator;  <span class="hljs-comment">// 比较器对象</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果比较器对象不为空，也就是自定义了比较器</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (cpr != <span class="hljs-keyword">null</span>) &#123;   </span><br><span class="line">        do &#123; <span class="hljs-comment">// 循环比较并确定元素应插入的位置(也就是找到该元素的父节点)</span></span><br><span class="line">            parent = t;  <span class="hljs-comment">// t就是root</span></span><br><span class="line"></span><br><span class="line">            <span class="hljs-comment">// 调用比较器对象的compare()方法，该方法返回一个整数</span></span><br><span class="line">            cmp = cpr.compare(<span class="hljs-built_in">key</span>, t.<span class="hljs-built_in">key</span>); </span><br><span class="line">            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)      <span class="hljs-comment">// 待插入元素的key"小于"当前位置元素的key，则查询左子树</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// 待插入元素的key"大于"当前位置元素的key，则查询右子树</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="hljs-keyword">else</span>              <span class="hljs-comment">// "相等"则替换其value。</span></span><br><span class="line">                <span class="hljs-keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 如果比较器对象为空，使用默认的比较机制</span></span><br><span class="line">    <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)</span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();</span><br><span class="line">        @SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">            Comparable&lt;? <span class="hljs-keyword">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-keyword">super</span> K&gt;) <span class="hljs-built_in">key</span>; <span class="hljs-comment">// 取出比较器对象</span></span><br><span class="line">        do &#123;  <span class="hljs-comment">// 同样是循环比较并确定元素应插入的位置(也就是找到该元素的父节点)</span></span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.<span class="hljs-built_in">key</span>); <span class="hljs-comment">// 同样调用比较方法并返回一个整数</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)       <span class="hljs-comment">// 待插入元素的key"小于"当前位置元素的key，则查询左子树</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 待插入元素的key"大于"当前位置元素的key，则查询右子树</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="hljs-keyword">else</span>               <span class="hljs-comment">// "相等"则替换其value。</span></span><br><span class="line">                <span class="hljs-keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="hljs-keyword">while</span> (t != <span class="hljs-keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="hljs-keyword">new</span> Entry&lt;&gt;(<span class="hljs-built_in">key</span>, value, parent);  <span class="hljs-comment">// 根据key找到父节点后新建一个节点</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 根据比较的结果来确定放在左子树还是右子树</span></span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    <span class="hljs-built_in">size</span>++;      <span class="hljs-comment">// 集合大小+1</span></span><br><span class="line">    modCount++;  <span class="hljs-comment">// 集合结构被修改次数+1</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的fixAfterInsertion便是节点插入后对树进行调整的方法，这里不做介绍。</p><h1 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h1><p>删除操作及对应TreeMap的deleteEntry方法，deleteEntry方法同样也只需按照二叉排序树的操作步骤实现即可，删除指定节点后，再对树进行调整即可。deleteEntry方法的实现源码如下：<br><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// 删除“红黑树的节点p”</span><br><span class="line">private void deleteEntry(Entry&lt;K,V&gt; p) &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (p.left != <span class="hljs-literal">null</span> &amp;&amp; p.right != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; <span class="hljs-attr">s</span> = successor (p);</span><br><span class="line">        p.<span class="hljs-attr">key</span> = s.key;</span><br><span class="line">        p.<span class="hljs-attr">value</span> = s.value;</span><br><span class="line">        <span class="hljs-attr">p</span> = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;K,V&gt; <span class="hljs-attr">replacement</span> = (p.left != <span class="hljs-literal">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (replacement != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        replacement.<span class="hljs-attr">parent</span> = p.parent;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p.<span class="hljs-attr">parent</span> == <span class="hljs-literal">null</span>)</span><br><span class="line">            <span class="hljs-attr">root</span> = replacement;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-attr">p</span> == p.parent.left)</span><br><span class="line">            p.parent.<span class="hljs-attr">left</span>  = replacement;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            p.parent.<span class="hljs-attr">right</span> = replacement;</span><br><span class="line"></span><br><span class="line">        p.<span class="hljs-attr">left</span> = p.<span class="hljs-attr">right</span> = p.<span class="hljs-attr">parent</span> = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (p.<span class="hljs-attr">color</span> == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p.<span class="hljs-attr">parent</span> == <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">        <span class="hljs-attr">root</span> = <span class="hljs-literal">null</span>;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (p.<span class="hljs-attr">color</span> == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (p.parent != <span class="hljs-literal">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (<span class="hljs-attr">p</span> == p.parent.left)</span><br><span class="line">                p.parent.<span class="hljs-attr">left</span> = <span class="hljs-literal">null</span>;</span><br><span class="line">            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-attr">p</span> == p.parent.right)</span><br><span class="line">                p.parent.<span class="hljs-attr">right</span> = <span class="hljs-literal">null</span>;</span><br><span class="line">            p.<span class="hljs-attr">parent</span> = <span class="hljs-literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>后面的fixAfterDeletion方法便是节点删除后对树进行调整的方法，这里不做介绍。</p><h1 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h1><p>一帮以getEntry()方法为基础的获取元素的方法，其中包括containsKey()，get()等。<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(<span class="hljs-built_in">key</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> (p==<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;</span><br><span class="line">    <span class="hljs-comment">// 如果有自定义比较器对象，就按照自定义规则遍历二叉树</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (comparator != <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> getEntryUsingComparator(<span class="hljs-built_in">key</span>);</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();</span><br><span class="line">    @SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="hljs-keyword">super</span> K&gt; k = (Comparable&lt;? <span class="hljs-keyword">super</span> K&gt;) <span class="hljs-built_in">key</span>;</span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="hljs-keyword">while</span> (p != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 按照默认比较规则遍历二叉树</span></span><br><span class="line">        <span class="hljs-built_in">int</span> cmp = k.compareTo(p.<span class="hljs-built_in">key</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (cmp &lt; <span class="hljs-number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cmp &gt; <span class="hljs-number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="hljs-keyword">else</span></span><br><span class="line">            <span class="hljs-keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="getFirstEntry-，getLastEntry"><a href="#getFirstEntry-，getLastEntry" class="headerlink" title="getFirstEntry()，getLastEntry()"></a>getFirstEntry()，getLastEntry()</h1><p>一帮以getFirstEntry()，getLastEntry()为基础的获取头和尾元素的方法，其中包括：firstKey()，lastKey()；firstEntry()，lastEntry()；pollFirstEntry()，pollLastEntry()；<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title">getFirstEntry</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 获取第一个元素也就是最小的元素，一直遍历左子树</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">while</span> (p.left != <span class="hljs-keyword">null</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; <span class="hljs-title">getLastEntry</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">// 获取最后个元素也就是最大的元素，一直遍历右子树</span></span><br><span class="line">    Entry&lt;K,V&gt; p = root;</span><br><span class="line">    <span class="hljs-keyword">if</span> (p != <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">while</span> (p.right != <span class="hljs-keyword">null</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">    <span class="hljs-keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TreeMap简介&quot;&gt;&lt;a href=&quot;#TreeMap简介&quot; class=&quot;headerlink&quot; title=&quot;TreeMap简介&quot;&gt;&lt;/a&gt;TreeMap简介&lt;/h1&gt;&lt;p&gt;TreeMap的基本概念：&lt;/p&gt;
&lt;p&gt;TreeMap集合是基于红黑树（Red-B
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="TreeMap" scheme="http://mindasoft.com/tags/TreeMap/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-HashSet源码剖析</title>
    <link href="http://mindasoft.com/2018/12/05/javase/HashSet%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/12/05/javase/HashSet源码剖析/</id>
    <published>2018-12-05T02:50:37.000Z</published>
    <updated>2018-12-05T02:58:14.721Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashSet简介"><a href="#HashSet简介" class="headerlink" title="HashSet简介"></a>HashSet简介</h1><p>HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。主要具有以下的特点：</p><ul><li>不保证set的迭代顺序，特别是它不保证该顺序恒久不变</li><li>有且<strong>只允许一个null元素</strong></li><li><strong>不允许有重复元素</strong>，这是因为<label style="color:red">HashSet是基于HashMap实现的，HashSet中的元素都存放在HashMap的key上面，而value中的值都是统一的一个private static final Object PRESENT = new Object();</label></li><li><p><strong>非同步的</strong>。如果多 个线程同时访问一个哈希set，而其中至少一个线程修改了该 set，那么它必须保持外部同步。这通常是通过对自然封装该set的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该set进行意外的不同步访问：</p><figure class="highlight gams hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">Set</span> s <span class="hljs-comment">= Collections.synchronizedSet(new HashSet(...))</span>;</span><br></pre></td></tr></table></figure></li><li><p>HashSet通过iterator()返回的迭代器是fail-fast的</p></li></ul><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>通过HashSet实现的接口可知，其支持所有集合操作，能被克隆，支持序列化<br><figure class="highlight groovy hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">-5024744406713321676</span>L;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//定义一个"虚拟"的static final Object对象作为HashMap的value</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashSet包含了两个重要的成员变量：map, PRESENT。</p><ol><li>map是一个HashMap<e, object="">对象，HashSet是由一个HashMap实例支持的。</e,></li><li>PRESENT是一个static final Object对象，用来作为HashMap中的value值。</li></ol><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>HashSet提供了四种方式的构造器，可以构造一个新的空 set，其底层 HashMap实例的默认初始容量是16，加载因子是 0.75，构造一个包含指定collection中的元素的新set，构造一个新的空set，其底层HashMap实例具有指定的初始容量和默认的加载因子（0.75），以及构造一个新的空set，其底层HashMap实例具有指定的初始容量和指定的加载因子。<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//默认的无参构造器，构造一个空的HashSet,实际底层会初始化一个空的HashMap，并使用默认初始容量为16和加载因子0.75。</span></span><br><span class="line"><span class="hljs-keyword">public</span> HashSet() &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;E, <span class="hljs-keyword">Object</span>&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//构造一个包含指定collection中的元素的新set。</span></span><br><span class="line"><span class="hljs-comment">//实际底层使用默认的加载因子0.75和足以包含指定collection中所有元素的初始容量来创建一个HashMap。</span></span><br><span class="line"><span class="hljs-keyword">public</span> HashSet(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;E, <span class="hljs-keyword">Object</span>&gt;(Math.<span class="hljs-built_in">max</span>((<span class="hljs-built_in">int</span>) (c.<span class="hljs-built_in">size</span>()/<span class="hljs-number">.75</span>f) + <span class="hljs-number">1</span>, <span class="hljs-number">16</span>));</span><br><span class="line">    addAll(c);  <span class="hljs-comment">//AbstractCollection.addAll(Collection&lt;? extends E&gt; c)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//以指定的初始容量和加载因子构造一个空的HashSet</span></span><br><span class="line"><span class="hljs-keyword">public</span> HashSet(<span class="hljs-built_in">int</span> initialCapacity, <span class="hljs-built_in">float</span> loadFactor) &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;E, <span class="hljs-keyword">Object</span>&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//以指定的initialCapacity和默认加载因子0.75构造一个空的HashSet</span></span><br><span class="line"><span class="hljs-keyword">public</span> HashSet(<span class="hljs-built_in">int</span> initialCapacity) &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;E, <span class="hljs-keyword">Object</span>&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 以指定的initialCapacity和loadFactor构造一个新的空链接哈希集合</span></span><br><span class="line"><span class="hljs-comment"> * 此构造函数为包访问权限，不对外公开，实际只是是对LinkedHashSet的支持</span></span><br><span class="line"><span class="hljs-comment"> * </span></span><br><span class="line"><span class="hljs-comment"> * @param      initialCapacity   初始容量</span></span><br><span class="line"><span class="hljs-comment"> * @param      loadFactor        加载因子</span></span><br><span class="line"><span class="hljs-comment"> * @param      dummy             标记，用于与其他的构造函数区分（可忽略）</span></span><br><span class="line"><span class="hljs-comment"> * @throws     IllegalArgumentException 如果初始容量小于零或加载因子为非正数</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line">HashSet(<span class="hljs-built_in">int</span> initialCapacity, <span class="hljs-built_in">float</span> loadFactor, <span class="hljs-built_in">boolean</span> dummy) &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> LinkedHashMap&lt;E, <span class="hljs-keyword">Object</span>&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h1><p>HashSet提供了add(E e)添加元素的方法，其调用的是底层HashMap中的put(K key, V value)方法，首先判断元素（也就是key）是否存在，如果不存在则插入，如果存在则不插入，这样HashSet中就不存在重复值。<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//如果此set中尚未包含指定元素，则添加指定元素</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.put(e, PRESENT)==<span class="hljs-keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>底层</strong>：当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该值确定对象在HashSet中的存储位置。在Hash集合中，不能同时存放两个相等的元素，而判断两个元素相等的标准是两个对象通过equals方法比较相等并且两个对象的HashCode方法返回值也相等。</p><p><strong>注意</strong>：对于HashSet中保存的对象，请注意正确重写其equals和hashCode方法，以保证放入的对象的唯一性。</p><h1 id="清空与删除"><a href="#清空与删除" class="headerlink" title="清空与删除"></a>清空与删除</h1><p>HashSet提供了remove(Object o)删除元素、clear()清除所有元素的方法。<br><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//如果指定元素存在于此set中，则将其移除</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-built_in">remove</span>(Object o) &#123;</span><br><span class="line">    <span class="hljs-built_in">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">remove</span>(o)==PRESENT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//从此set中移除所有元素</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">clear</span>() &#123;</span><br><span class="line">    <span class="hljs-built_in">map</span>.<span class="hljs-built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>HashSet提供了contains(Object o)查看是否包含指定元素的方法，其底层调用的是HashMap.containsKey(Object key)判断是否包含指定key。<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//如果此set包含指定元素，则返回 true</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">return</span> map.<span class="hljs-title">containsKey</span><span class="hljs-params">(o)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="其他公开的方法"><a href="#其他公开的方法" class="headerlink" title="其他公开的方法"></a>其他公开的方法</h1><p>size()、isEmpty()、clone()<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//返回此set中的元素的数量</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//如果此set不包含任何元素，则返回 true</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isEmpty() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//返回此 HashSet实例的浅表副本</span></span><br><span class="line">@SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">Object</span> clone() &#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) <span class="hljs-keyword">super</span>.clone();</span><br><span class="line">        newSet.<span class="hljs-built_in">map</span> = (<span class="hljs-keyword">HashMap</span>&lt;E, <span class="hljs-keyword">Object</span>&gt;) <span class="hljs-built_in">map</span>.clone();</span><br><span class="line">        <span class="hljs-keyword">return</span> newSet;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>支持序列化的写入函数writeObject(java.io.ObjectOutputStream s)和读取函数readObject(java.io.ObjectInputStream s)：<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//java.io.Serializable的写入函数，将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> writeObject(java.io.ObjectOutputStream s)</span><br><span class="line">    <span class="hljs-keyword">throws</span> java.io.IOException &#123;</span><br><span class="line">    <span class="hljs-comment">// Write out any hidden serialization magic</span></span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out HashMap capacity and load factor</span></span><br><span class="line">    s.writeInt(<span class="hljs-built_in">map</span>.capacity());</span><br><span class="line">    s.writeFloat(<span class="hljs-built_in">map</span>.loadFactor());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out size</span></span><br><span class="line">    s.writeInt(<span class="hljs-built_in">map</span>.<span class="hljs-built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (E e : <span class="hljs-built_in">map</span>.keySet())</span><br><span class="line">        s.writeObject(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// java.io.Serializable的读取函数，将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> readObject(java.io.ObjectInputStream s)</span><br><span class="line">    <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException &#123;</span><br><span class="line">    <span class="hljs-comment">// Read in any hidden serialization magic</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read capacity and verify non-negative.</span></span><br><span class="line">    <span class="hljs-built_in">int</span> capacity = s.readInt();</span><br><span class="line">    <span class="hljs-keyword">if</span> (capacity &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Illegal capacity: "</span> +</span><br><span class="line">                                         capacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read load factor and verify positive and non NaN.</span></span><br><span class="line">    <span class="hljs-built_in">float</span> loadFactor = s.readFloat();</span><br><span class="line">    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Illegal load factor: "</span> +</span><br><span class="line">                                         loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read size and verify non-negative.</span></span><br><span class="line">    <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span> = s.readInt();</span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvalidObjectException(<span class="hljs-string">"Illegal size: "</span> +</span><br><span class="line">                                         <span class="hljs-built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Set the capacity according to the size and load factor ensuring that</span></span><br><span class="line">    <span class="hljs-comment">// the HashMap is at least 25% full but clamping to maximum capacity.</span></span><br><span class="line">    capacity = (<span class="hljs-built_in">int</span>) Math.<span class="hljs-built_in">min</span>(<span class="hljs-built_in">size</span> * Math.<span class="hljs-built_in">min</span>(<span class="hljs-number">1</span> / loadFactor, <span class="hljs-number">4.0</span>f),</span><br><span class="line">            <span class="hljs-keyword">HashMap</span>.MAXIMUM_CAPACITY);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Create backing HashMap</span></span><br><span class="line">    <span class="hljs-built_in">map</span> = (((HashSet&lt;?&gt;)<span class="hljs-keyword">this</span>) <span class="hljs-keyword">instanceof</span> LinkedHashSet ?</span><br><span class="line">           <span class="hljs-keyword">new</span> LinkedHashMap&lt;E,<span class="hljs-keyword">Object</span>&gt;(capacity, loadFactor) :</span><br><span class="line">           <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;E,<span class="hljs-keyword">Object</span>&gt;(capacity, loadFactor));</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Read in all elements in the proper order.</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">size</span>; i++) &#123;</span><br><span class="line">        @SuppressWarnings(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">            E e = (E) s.readObject();</span><br><span class="line">        <span class="hljs-built_in">map</span>.put(e, PRESENT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="HashSet的迭代"><a href="#HashSet的迭代" class="headerlink" title="HashSet的迭代"></a>HashSet的迭代</h1><p>　HashSet通过调用HashMap.keySet()返回<key, value="">对中的key集以此得到集合的迭代器。<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//返回对此 set中元素进行迭代的迭代器</span></span><br><span class="line"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.keySet().iterator(); <span class="hljs-comment">//HashMap.keySet()返回&lt;key, value&gt;对中的key集</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></key,></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashSet简介&quot;&gt;&lt;a href=&quot;#HashSet简介&quot; class=&quot;headerlink&quot; title=&quot;HashSet简介&quot;&gt;&lt;/a&gt;HashSet简介&lt;/h1&gt;&lt;p&gt;HashSet实现Set接口，由哈希表（实际上是一个HashMap实例）支持。主要具
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="HashSet" scheme="http://mindasoft.com/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-LinkedList源码剖析</title>
    <link href="http://mindasoft.com/2018/11/27/javase/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/27/javase/LinkedList源码剖析/</id>
    <published>2018-11-27T07:24:37.000Z</published>
    <updated>2018-11-27T06:27:35.610Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList是List接口链表的实现。基于链表实现的方式使得LinkedList在插入和删除时更优于ArrayList，而随机访问则比ArrayList逊色些。</p><p>LinkedList实现所有可选的列表操作，并允许所有的元素包括null。</p><p>除了实现 List 接口外，LinkedList 类还为在列表的开头及结尾 get、remove 和 insert 元素提供了统一的命名方法。这些操作允许将链接列表用作堆栈、队列或双端队列。</p><p>此类实现 Deque 接口，为 add、poll 提供先进先出队列操作，以及其他堆栈和双端队列操作。</p><p>所有操作都是按照双重链接列表的需要执行的。在列表中编索引的操作将从开头或结尾遍历列表（从靠近指定索引的一端）。</p><p>同时，与ArrayList一样此实现不是同步的。</p><p>（以上摘自JDK 6.0 API）。</p><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先我们先看LinkedList的定义：</p><figure class="highlight actionscript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;  </span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;  </span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>从这段代码中我们可以清晰地看出LinkedList继承AbstractSequentialList，实现List、Deque、Cloneable、Serializable。其中AbstractSequentialList提供了 List 接口的骨干实现，从而最大限度地减少了实现受“连续访问”数据存储（如链接列表）支持的此接口所需的工作,从而以减少实现List接口的复杂度。Deque一个线性 collection，支持在两端插入和移除元素，定义了双端队列的操作。</p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>在LinkedList中提供了两个基本属性size、header。<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry&lt;E&gt; header = <span class="hljs-keyword">new</span> Entry&lt;E&gt;(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);  </span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span> = <span class="hljs-number">0</span>;</span><br></pre></td></tr></table></figure></p><p>其中size表示的LinkedList的大小，header表示链表的表头，Entry为节点对象。<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> Entry&lt;E&gt; &#123;  </span><br><span class="line">    E element;        <span class="hljs-comment">//元素节点  </span></span><br><span class="line">    Entry&lt;E&gt; <span class="hljs-keyword">next</span>;    <span class="hljs-comment">//下一个元素  </span></span><br><span class="line">    Entry&lt;E&gt; <span class="hljs-keyword">previous</span>;  <span class="hljs-comment">//上一个元素  </span></span><br><span class="line"></span><br><span class="line">    Entry(E element, Entry&lt;E&gt; <span class="hljs-keyword">next</span>, Entry&lt;E&gt; <span class="hljs-keyword">previous</span>) &#123;  </span><br><span class="line">        <span class="hljs-keyword">this</span>.element = element;  </span><br><span class="line">        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">next</span> = <span class="hljs-keyword">next</span>;  </span><br><span class="line">        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">previous</span> = <span class="hljs-keyword">previous</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面为Entry对象的源代码，Entry为LinkedList的内部类，它定义了存储的元素。该元素的前一个元素、后一个元素，这是典型的双向链表定义方式。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>LinkedList提高了两个构造方法：LinkedLis()和LinkedList(Collection&lt;? extends E&gt; c)。<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> *  构造一个空列表。 </span></span><br><span class="line"><span class="hljs-comment"> */</span>  </span><br><span class="line"><span class="hljs-keyword">public</span> LinkedList() &#123;  </span><br><span class="line">    header.<span class="hljs-keyword">next</span> = header.<span class="hljs-keyword">previous</span> = header;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> *  构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。 </span></span><br><span class="line"><span class="hljs-comment"> */</span>  </span><br><span class="line"><span class="hljs-keyword">public</span> LinkedList(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c) &#123;  </span><br><span class="line">    <span class="hljs-keyword">this</span>();  </span><br><span class="line">    addAll(c);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>LinkedList()构造一个空列表。里面没有任何元素，仅仅只是将header节点的前一个元素、后一个元素都指向自身。<br>LinkedList(Collection&lt;? extends E&gt; c)： 构造一个包含指定 collection 中的元素的列表，这些元素按其 collection 的迭代器返回的顺序排列。该构造函数首先会调用LinkedList()，构造一个空列表，然后调用了addAll()方法将Collection中的所有元素添加到列表中。以下是addAll()的源代码：<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment">     *  添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。 </span></span><br><span class="line"><span class="hljs-comment">     */</span>  </span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> addAll(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c) &#123;  </span><br><span class="line">        <span class="hljs-keyword">return</span> addAll(<span class="hljs-keyword">size</span>, c);  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    <span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment">     * 将指定 collection 中的所有元素从指定位置开始插入此列表。其中index表示在其中插入指定collection中第一个元素的索引 </span></span><br><span class="line"><span class="hljs-comment">     */</span>  </span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> addAll(<span class="hljs-keyword">int</span> index, Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c) &#123;  </span><br><span class="line">        <span class="hljs-comment">//若插入的位置小于0或者大于链表长度，则抛出IndexOutOfBoundsException异常  </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-keyword">size</span>)  </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Index: "</span> + index + <span class="hljs-string">", Size: "</span> + <span class="hljs-keyword">size</span>);  </span><br><span class="line">        Object[] a = c.toArray();  </span><br><span class="line">        <span class="hljs-keyword">int</span> numNew = a.length;    <span class="hljs-comment">//插入元素的个数  </span></span><br><span class="line">        <span class="hljs-comment">//若插入的元素为空，则返回false  </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (numNew == <span class="hljs-number">0</span>)  </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  </span><br><span class="line">        <span class="hljs-comment">//modCount:在AbstractList中定义的，表示从结构上修改列表的次数  </span></span><br><span class="line">        modCount++;  </span><br><span class="line">        <span class="hljs-comment">//获取插入位置的节点，若插入的位置在size处，则是头节点，否则获取index位置处的节点  </span></span><br><span class="line">        Entry&lt;E&gt; successor = (index == <span class="hljs-keyword">size</span> ? header : entry(index));  </span><br><span class="line">        <span class="hljs-comment">//插入位置的前一个节点，在插入过程中需要修改该节点的next引用：指向插入的节点元素  </span></span><br><span class="line">        Entry&lt;E&gt; predecessor = successor.<span class="hljs-keyword">previous</span>;  </span><br><span class="line">        <span class="hljs-comment">//执行插入动作  </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numNew; i++) &#123;  </span><br><span class="line">            <span class="hljs-comment">//构造一个节点e，这里已经执行了插入节点动作同时修改了相邻节点的指向引用  </span></span><br><span class="line">            <span class="hljs-comment">//  </span></span><br><span class="line">            Entry&lt;E&gt; e = <span class="hljs-keyword">new</span> Entry&lt;E&gt;((E) a[i], successor, predecessor);  </span><br><span class="line">            <span class="hljs-comment">//将插入位置前一个节点的下一个元素引用指向当前元素  </span></span><br><span class="line">            predecessor.<span class="hljs-keyword">next</span> = e;  </span><br><span class="line">            <span class="hljs-comment">//修改插入位置的前一个节点，这样做的目的是将插入位置右移一位，保证后续的元素是插在该元素的后面，确保这些元素的顺序  </span></span><br><span class="line">            predecessor = e;  </span><br><span class="line">        &#125;  </span><br><span class="line">        successor.<span class="hljs-keyword">previous</span> = predecessor;  </span><br><span class="line">        <span class="hljs-comment">//修改容量大小  </span></span><br><span class="line">        <span class="hljs-keyword">size</span> += numNew;  </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>在addAll()方法中，涉及到了两个方法，一个是entry(int index)，该方法为LinkedList的私有方法，主要是用来查找index位置的节点元素。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** </span></span><br><span class="line"><span class="hljs-comment"> * 返回指定位置(若存在)的节点元素 </span></span><br><span class="line"><span class="hljs-comment"> */</span>  </span><br><span class="line"><span class="hljs-keyword">private</span> Entry&lt;E&gt; entry(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;  </span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span> || <span class="hljs-keyword">index</span> &gt;= size)  </span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Index: "</span> + <span class="hljs-keyword">index</span> + <span class="hljs-string">", Size: "</span>  </span><br><span class="line">                + size);  </span><br><span class="line">    <span class="hljs-comment">//头部节点  </span></span><br><span class="line">    Entry&lt;E&gt; e = header;  </span><br><span class="line">    <span class="hljs-comment">//判断遍历的方向  </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;  </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-keyword">index</span>; i++)  </span><br><span class="line">            e = e.next;  </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;  </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = size; i &gt; <span class="hljs-keyword">index</span>; i--)  </span><br><span class="line">            e = e.previous;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="hljs-keyword">return</span> e;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从该方法有两个遍历方向中我们也可以看出LinkedList是双向链表，这也是在构造方法中为什么需要将header的前、后节点均指向自己。</p><p>如果对数据结构有点了解，对上面所涉及的内容应该问题，我们只需要清楚一点：LinkedList是双向链表，其余都迎刃而解。<br>由于篇幅有限，下面将就LinkedList中几个常用的方法进行源码分析。</p><h2 id="增加方法"><a href="#增加方法" class="headerlink" title="增加方法"></a>增加方法</h2><p>add(E e): 将指定元素添加到此列表的结尾。<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;  </span><br><span class="line">    addBefore(e, header);  </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法调用addBefore方法，然后直接返回true，对于addBefore()而已，它为LinkedList的私有方法。</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123;  </span><br><span class="line">    <span class="hljs-comment">//利用Entry构造函数构建一个新节点 newEntry，  </span></span><br><span class="line">    Entry&lt;E&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Entry</span>&lt;E&gt;(e, entry, entry.previous);  </span><br><span class="line">    <span class="hljs-comment">//修改newEntry的前后节点的引用，确保其链表的引用关系是正确的  </span></span><br><span class="line">    <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span>.previous.next = <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span>;  </span><br><span class="line">    <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span>.next.previous = <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span>;  </span><br><span class="line">    <span class="hljs-comment">//容量+1  </span></span><br><span class="line">    size++;  </span><br><span class="line">    <span class="hljs-comment">//修改次数+1  </span></span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Entry</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在addBefore方法中无非就是做了这件事：构建一个新节点newEntry，然后修改其前后的引用。</p><p>LinkedList还提供了其他的增加方法：</p><p>add(int index, E element)：在此列表中指定的位置插入指定的元素。</p><p>addAll(Collection&lt;? extends E&gt; c)：添加指定 collection 中的所有元素到此列表的结尾，顺序是指定 collection 的迭代器返回这些元素的顺序。</p><p>addAll(int index, Collection&lt;? extends E&gt; c)：将指定 collection 中的所有元素从指定位置开始插入此列表。</p><p>AddFirst(E e): 将指定元素插入此列表的开头。</p><p>addLast(E e): 将指定元素添加到此列表的结尾。</p><h2 id="移除方法"><a href="#移除方法" class="headerlink" title="移除方法"></a>移除方法</h2><p>remove(Object o)：从此列表中移除首次出现的指定元素（如果存在）。该方法的源代码如下：<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> remove(Object o) &#123;  </span><br><span class="line">    <span class="hljs-keyword">if</span> (o==<span class="hljs-keyword">null</span>) &#123;  </span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;E&gt; e = header.<span class="hljs-keyword">next</span>; e != header; e = e.<span class="hljs-keyword">next</span>) &#123;  </span><br><span class="line">            <span class="hljs-keyword">if</span> (e.element==<span class="hljs-keyword">null</span>) &#123;  </span><br><span class="line">                remove(e);  </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;  </span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;E&gt; e = header.<span class="hljs-keyword">next</span>; e != header; e = e.<span class="hljs-keyword">next</span>) &#123;  </span><br><span class="line">            <span class="hljs-keyword">if</span> (o.equals(e.element)) &#123;  </span><br><span class="line">                remove(e);  </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法首先会判断移除的元素是否为null，然后迭代这个链表找到该元素节点，最后调用remove(Entry<e> e)，remove(Entry<e> e)为私有方法，是LinkedList中所有移除方法的基础方法，如下：</e></e></p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> E remove(Entry&lt;E&gt; e) &#123;  </span><br><span class="line">    <span class="hljs-keyword">if</span> (e == header)  </span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();  </span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//保留被移除的元素：要返回  </span></span><br><span class="line">    E result = e.element;  </span><br><span class="line">      </span><br><span class="line">    <span class="hljs-comment">//将该节点的前一节点的next指向该节点后节点  </span></span><br><span class="line">    e.<span class="hljs-keyword">previous</span>.<span class="hljs-keyword">next</span> = e.<span class="hljs-keyword">next</span>;  </span><br><span class="line">    <span class="hljs-comment">//将该节点的后一节点的previous指向该节点的前节点  </span></span><br><span class="line">    <span class="hljs-comment">//这两步就可以将该节点从链表从除去：在该链表中是无法遍历到该节点的  </span></span><br><span class="line">    e.<span class="hljs-keyword">next</span>.<span class="hljs-keyword">previous</span> = e.<span class="hljs-keyword">previous</span>;  </span><br><span class="line">    <span class="hljs-comment">//将该节点归空  </span></span><br><span class="line">    e.<span class="hljs-keyword">next</span> = e.<span class="hljs-keyword">previous</span> = <span class="hljs-keyword">null</span>;  </span><br><span class="line">    e.element = <span class="hljs-keyword">null</span>;  </span><br><span class="line">    <span class="hljs-keyword">size</span>--;  </span><br><span class="line">    modCount++;  </span><br><span class="line">    <span class="hljs-keyword">return</span> result;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的移除方法：</p><p>clear()： 从此列表中移除所有元素。</p><p>remove()：获取并移除此列表的头（第一个元素）。</p><p>remove(int index)：移除此列表中指定位置处的元素。</p><p>remove(Objec o)：从此列表中移除首次出现的指定元素（如果存在）。</p><p>removeFirst()：移除并返回此列表的第一个元素。</p><p>removeFirstOccurrence(Object o)：从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表时）。</p><p>removeLast()：移除并返回此列表的最后一个元素。</p><p>removeLastOccurrence(Object o)：从此列表中移除最后一次出现的指定元素（从头部到尾部遍历列表时）。</p><h2 id="查找方法"><a href="#查找方法" class="headerlink" title="查找方法"></a>查找方法</h2><p>对于查找方法的源码就没有什么好介绍了，无非就是迭代，比对，然后就是返回当前值。</p><p>get(int index)：返回此列表中指定位置处的元素。</p><p>getFirst()：返回此列表的第一个元素。</p><p>getLast()：返回此列表的最后一个元素。</p><p>indexOf(Object o)：返回此列表中首次出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。</p><p>lastIndexOf(Object o)：返回此列表中最后出现的指定元素的索引，如果此列表中不包含该元素，则返回 -1。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;LinkedList与ArrayList一样实现List接口，只是ArrayList是List接口的大小可变数组的实现，LinkedList
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="LinkedList" scheme="http://mindasoft.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-ArrayList源码剖析</title>
    <link href="http://mindasoft.com/2018/11/27/javase/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/27/javase/ArrayList源码剖析/</id>
    <published>2018-11-27T06:04:37.000Z</published>
    <updated>2018-11-27T06:49:43.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ArrayList概述"><a href="#ArrayList概述" class="headerlink" title="ArrayList概述"></a>ArrayList概述</h1><p>ArrayList是实现List接口的动态数组，所谓动态就是它的大小是可变的。实现了所有可选列表操作，并允许包括 null 在内的所有元素。除了实现 List 接口外，此类还提供一些方法来操作内部用来存储列表的数组的大小。</p><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。默认初始容量为10。随着ArrayList中元素的增加，它的容量也会不断的自动增长。在每次添加新的元素时，ArrayList都会检查是否需要进行扩容操作，扩容操作带来数据向新数组的重新拷贝，所以如果我们知道具体业务数据量，在构造ArrayList时可以给ArrayList指定一个初始容量，这样就会减少扩容时数据的拷贝问题。当然在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p><p>注意，ArrayList实现<label style="color:red">不是同步</label>的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。所以为了保证同步，最好的办法是在创建时完成，以防止意外对列表进行不同步的访问：<br><figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">List</span> <span class="hljs-built_in">list</span> = Collections.synchronizedList(<span class="hljs-literal">new</span> ArrayList(<span class="hljs-params">...</span>));</span><br></pre></td></tr></table></figure></p><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>ArrayList我们使用的实在是太多了，非常熟悉，所以在这里将不介绍它的使用方法。ArrayList是实现List接口的，底层采用数组实现，所以它的操作基本上都是基于对数组的操作。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span></span><br><span class="line"><span class="hljs-class">     <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>,<span class="hljs-title">Serializable</span></span></span><br><span class="line"><span class="hljs-class">     </span>&#123;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 序列版本号</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189</span>L;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ArrayList基于该数组实现，用该数组保存数据</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">Object</span>[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ArrayList中实际数据的数量</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>;</span><br></pre></td></tr></table></figure><p>transient 为java关键字，为变量修饰符，如果用transient声明一个实例变量，当对象存储时，它的值不需要维持。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的。<br>这里Object[] elementData，就是我们的ArrayList容器，下面介绍的基本操作都是基于该elementData变量来进行操作的。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>ArrayList提供了三个构造函数：<br>ArrayList()：默认构造函数，提供初始容量为10的空列表。<br>ArrayList(int initialCapacity)：构造一个具有指定初始容量的空列表。<br>ArrayList(Collection&lt;? extends E&gt; c)：构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 构造一个初始容量为 10 的空列表</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> ArrayList() &#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 构造一个具有指定初始容量的空列表。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> ArrayList(<span class="hljs-keyword">int</span> initialCapacity) &#123;</span><br><span class="line">    <span class="hljs-keyword">super</span>();</span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span></span><br><span class="line">                + initialCapacity);</span><br><span class="line">    <span class="hljs-keyword">this</span>.elementData = <span class="hljs-keyword">new</span> Object[initialCapacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> *  构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> ArrayList(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="hljs-keyword">size</span> = elementData.length;</span><br><span class="line">    <span class="hljs-comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (elementData.getClass() != Object[].<span class="hljs-keyword">class</span>)</span><br><span class="line">        elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">size</span>, Object[].<span class="hljs-keyword">class</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h2><p>ArrayList提供了add(E e)、add(int index, E element)、addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)、set(int index, E element)这个五个方法来实现ArrayList增加。</p><p>add(E e)：将指定的元素添加到此列表的尾部。<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;</span><br><span class="line">    ensureCapacity(<span class="hljs-built_in">size</span> + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span></span><br><span class="line">    elementData[<span class="hljs-built_in">size</span>++] = e;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里ensureCapacity()方法是对ArrayList集合进行扩容操作，elementData(size++) = e，将列表末尾元素指向e。</p><hr><p>add(int index, E element)：将指定的元素插入此列表中的指定位置。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, E element) &#123;</span><br><span class="line">    <span class="hljs-comment">//判断索引位置是否正确</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt; size || <span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(</span><br><span class="line">        <span class="hljs-string">"Index: "</span>+<span class="hljs-keyword">index</span>+<span class="hljs-string">", Size: "</span>+size);</span><br><span class="line">    <span class="hljs-comment">//扩容检测</span></span><br><span class="line">    ensureCapacity(size+<span class="hljs-number">1</span>);  </span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     * 对源数组进行复制处理（位移），从index + 1到size-index。</span></span><br><span class="line"><span class="hljs-comment">     * 主要目的就是空出index位置供数据插入，</span></span><br><span class="line"><span class="hljs-comment">     * 即向右移动当前位于该位置的元素以及所有后续元素。 </span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    System.arraycopy(elementData, <span class="hljs-keyword">index</span>, elementData, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>,</span><br><span class="line">             size - <span class="hljs-keyword">index</span>);</span><br><span class="line">    <span class="hljs-comment">//在指定位置赋值</span></span><br><span class="line">    elementData[<span class="hljs-keyword">index</span>] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个方法中最根本的方法就是System.arraycopy()方法，该方法的根本目的就是将index位置空出来以供新数据插入，这里需要进行数组数据的右移，这是非常麻烦和耗时的，所以如果指定的数据集合需要进行大量插入（中间插入）操作，推荐使用LinkedList。</p><hr><p>addAll(Collection&lt;? extends E&gt; c)：按照指定 collection 的迭代器所返回的元素顺序，将该 collection 中的所有元素添加到此列表的尾部。</p><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> addAll(Collection&lt;? <span class="hljs-keyword">extends</span> E&gt; c) &#123;</span><br><span class="line">    <span class="hljs-comment">// 将集合C转换成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="hljs-keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="hljs-comment">// 扩容处理，大小为size + numNew</span></span><br><span class="line">    ensureCapacity(<span class="hljs-keyword">size</span> + numNew); <span class="hljs-comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, <span class="hljs-keyword">size</span>, numNew);</span><br><span class="line">    <span class="hljs-keyword">size</span> += numNew;</span><br><span class="line">    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法无非就是使用System.arraycopy()方法将C集合(先准换为数组)里面的数据复制到elementData数组中。这里就稍微介绍下System.arraycopy()，因为下面还将大量用到该方法。该方法的原型为：public static void arraycopy(Object src, int srcPos,Object dest, int destPos, int length)。它的根本目的就是进行数组元素的复制。即从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。将源数组src从srcPos位置开始复制到dest数组中，复制长度为length，数据从dest的destPos位置开始粘贴。</p><hr><p>addAll(int index, Collection&lt;? extends E&gt; c)：从指定的位置开始，将指定 collection 中的所有元素插入到此列表中。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> addAll(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    <span class="hljs-comment">//判断位置是否正确</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">index</span> &gt; size || <span class="hljs-keyword">index</span> &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException(<span class="hljs-string">"Index: "</span> + <span class="hljs-keyword">index</span> + <span class="hljs-string">", Size: "</span></span><br><span class="line">                + size);</span><br><span class="line">    <span class="hljs-comment">//转换成数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="hljs-keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="hljs-comment">//ArrayList容器扩容处理</span></span><br><span class="line">    ensureCapacity(size + numNew); <span class="hljs-comment">// Increments modCount</span></span><br><span class="line">    <span class="hljs-comment">//ArrayList容器数组向右移动的位置</span></span><br><span class="line">    <span class="hljs-keyword">int</span> numMoved = size - <span class="hljs-keyword">index</span>;</span><br><span class="line">    <span class="hljs-comment">//如果移动位置大于0，则将ArrayList容器的数据向右移动numMoved个位置，确保增加的数据能够增加</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, <span class="hljs-keyword">index</span>, elementData, <span class="hljs-keyword">index</span> + numNew,</span><br><span class="line">                numMoved);</span><br><span class="line">    <span class="hljs-comment">//添加数组</span></span><br><span class="line">    System.arraycopy(a, <span class="hljs-number">0</span>, elementData, <span class="hljs-keyword">index</span>, numNew);</span><br><span class="line">    <span class="hljs-comment">//容器容量变大</span></span><br><span class="line">    size += numNew;   </span><br><span class="line">    <span class="hljs-keyword">return</span> numNew != <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><p>set(int index, E element)：用指定的元素替代此列表中指定位置上的元素。<br><figure class="highlight n1ql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public E set(int <span class="hljs-keyword">index</span>, <span class="hljs-built_in">E</span> <span class="hljs-keyword">element</span>) &#123;</span><br><span class="line">        //检测插入的位置是否越界</span><br><span class="line">        RangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line"></span><br><span class="line">        E oldValue = (E) elementData[<span class="hljs-keyword">index</span>];</span><br><span class="line">        //替代</span><br><span class="line">        elementData[<span class="hljs-keyword">index</span>] = <span class="hljs-keyword">element</span>;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>ArrayList提供了remove(int index)、remove(Object o)、removeRange(int fromIndex, int toIndex)、removeAll()四个方法进行元素的删除。</p><p>remove(int index)：移除此列表中指定位置上的元素。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> E remove(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">//位置验证</span></span><br><span class="line">        RangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="hljs-comment">//需要删除的元素</span></span><br><span class="line">        E oldValue = (E) elementData[<span class="hljs-keyword">index</span>];   </span><br><span class="line">        <span class="hljs-comment">//向左移的位数</span></span><br><span class="line">        <span class="hljs-keyword">int</span> numMoved = size - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-comment">//若需要移动，则想左移动numMoved位</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, <span class="hljs-keyword">index</span> + <span class="hljs-number">1</span>, elementData, <span class="hljs-keyword">index</span>,</span><br><span class="line">                    numMoved);</span><br><span class="line">        <span class="hljs-comment">//置空最后一个元素</span></span><br><span class="line">        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p>remove(Object o)：移除此列表中首次出现的指定元素（如果存在）。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> remove(Object o) &#123;</span><br><span class="line">        <span class="hljs-comment">//因为ArrayList中允许存在null，所以需要进行null判断</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; size; <span class="hljs-keyword">index</span>++)</span><br><span class="line">                <span class="hljs-keyword">if</span> (elementData[<span class="hljs-keyword">index</span>] == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">                    <span class="hljs-comment">//移除这个位置的元素</span></span><br><span class="line">                    fastRemove(<span class="hljs-keyword">index</span>);</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>; <span class="hljs-keyword">index</span> &lt; size; <span class="hljs-keyword">index</span>++)</span><br><span class="line">                <span class="hljs-keyword">if</span> (o.equals(elementData[<span class="hljs-keyword">index</span>])) &#123;</span><br><span class="line">                    fastRemove(<span class="hljs-keyword">index</span>);</span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中fastRemove()方法用于移除指定位置的元素。如下<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> fastRemove(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="hljs-keyword">int</span> numMoved = size - <span class="hljs-keyword">index</span> - <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, <span class="hljs-keyword">index</span>+<span class="hljs-number">1</span>, elementData, <span class="hljs-keyword">index</span>,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// Let gc do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p>removeRange(int fromIndex, int toIndex)：移除列表中索引在 fromIndex（包括）和 toIndex（不包括）之间的所有元素。<br><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> removeRange(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex) &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="hljs-keyword">int</span> numMoved = <span class="hljs-keyword">size</span> - toIndex;</span><br><span class="line">        System</span><br><span class="line">                .arraycopy(elementData, toIndex, elementData, fromIndex,</span><br><span class="line">                        numMoved);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// Let gc do its work</span></span><br><span class="line">        <span class="hljs-keyword">int</span> newSize = <span class="hljs-keyword">size</span> - (toIndex - fromIndex);</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">size</span> != newSize)</span><br><span class="line">            elementData[--<span class="hljs-keyword">size</span>] = <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><hr><p>removeAll()：是继承自AbstractCollection的方法，ArrayList本身并没有提供实现。<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">removeAll</span><span class="hljs-params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">boolean</span> modified = <span class="hljs-keyword">false</span>;</span><br><span class="line">        Iterator&lt;?&gt; e = iterator();</span><br><span class="line">        <span class="hljs-keyword">while</span> (e.hasNext()) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (c.contains(e.next())) &#123;</span><br><span class="line">                e.remove();</span><br><span class="line">                modified = <span class="hljs-keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>ArrayList提供了get(int index)用读取ArrayList中的元素。由于ArrayList是动态数组，所以我们完全可以根据下标来获取ArrayList中的元素，而且速度还比较快，故ArrayList长于随机访问。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> E get(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;</span><br><span class="line">    RangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> (E) elementData[<span class="hljs-keyword">index</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>在上面的新增方法的源码中我们发现每个方法中都存在这个方法：ensureCapacity()，该方法就是ArrayList的扩容方法。在前面就提过ArrayList每次新增元素时都会需要进行容量检测判断，若新增元素后元素的个数会超过ArrayList的容量，就会进行扩容操作来满足新增元素的需求。所以当我们清楚知道业务数据量或者需要插入大量元素前，我可以使用ensureCapacity来手动增加ArrayList实例的容量，以减少递增式再分配的数量。<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">    <span class="hljs-comment">//修改计时器</span></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="hljs-comment">//ArrayList容量大小</span></span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     * 若当前需要的长度大于当前数组的长度时，进行扩容操作</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">        Object oldData[] = elementData;</span><br><span class="line">        <span class="hljs-comment">//计算新的容量大小，为当前容量的1.5倍</span></span><br><span class="line">        int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = (oldCapacity * <span class="hljs-number">3</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;</span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> &lt; minCapacity)</span><br><span class="line">            <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;</span><br><span class="line">        <span class="hljs-comment">//数组拷贝，生成新的数组</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这里有一个疑问，为什么每次扩容处理会是1.5倍，而不是2.5、3、4倍呢？通过google查找，发现1.5倍的扩容是最好的倍数。因为一次性扩容太大(例如2.5倍)可能会浪费更多的内存(1.5倍最多浪费33%，而2.5被最多会浪费60%，3.5倍则会浪费71%……)。但是一次性扩容太小，需要多次对数组重新分配内存，对性能消耗比较严重。所以1.5倍刚刚好，既能满足性能需求，也不会造成很大的内存消耗。</p><p>处理这个ensureCapacity()这个扩容数组外，ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize()方法来实现。该方法可以最小化ArrayList实例的存储量。</p><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> trimToSize() &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="hljs-built_in">if</span> (<span class="hljs-built_in">size</span> &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, <span class="hljs-built_in">size</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="subList"><a href="#subList" class="headerlink" title="subList"></a>subList</h2><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> List&lt;E&gt; subList(<span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex) &#123;</span><br><span class="line">    subListRangeCheck(fromIndex, toIndex, <span class="hljs-built_in">size</span>);</span><br><span class="line">    <span class="hljs-built_in">return</span> <span class="hljs-keyword">new</span> SubList(<span class="hljs-keyword">this</span>, <span class="hljs-number">0</span>, fromIndex, toIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subListRangeCheck方式是判断fromIndex、toIndex是否合法，如果合法就直接返回一个subList对象，注意在产生该new该对象的时候传递了一个参数 this ，该参数非常重要，因为他代表着原始list。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 继承AbstractList类，实现RandomAccess接口</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">RandomAccess</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbstractList&lt;E&gt; parent;    <span class="hljs-comment">//列表</span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> parentOffset;   </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset;</span><br><span class="line">    <span class="hljs-keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//构造函数</span></span><br><span class="line">    SubList(AbstractList&lt;E&gt; parent,</span><br><span class="line">            <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> fromIndex, <span class="hljs-keyword">int</span> toIndex) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="hljs-keyword">this</span>.parentOffset = fromIndex;</span><br><span class="line">        <span class="hljs-keyword">this</span>.offset = offset + fromIndex;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size = toIndex - fromIndex;</span><br><span class="line">        <span class="hljs-keyword">this</span>.modCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//set方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> E set(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, E e) &#123;</span><br><span class="line">        rangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E oldValue = ArrayList.<span class="hljs-keyword">this</span>.elementData(offset + <span class="hljs-keyword">index</span>);</span><br><span class="line">        ArrayList.<span class="hljs-keyword">this</span>.elementData[offset + <span class="hljs-keyword">index</span>] = e;</span><br><span class="line">        <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//get方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> E get(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;</span><br><span class="line">        rangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="hljs-keyword">return</span> ArrayList.<span class="hljs-keyword">this</span>.elementData(offset + <span class="hljs-keyword">index</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//add方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>, E e) &#123;</span><br><span class="line">        rangeCheckForAdd(<span class="hljs-keyword">index</span>);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        parent.add(parentOffset + <span class="hljs-keyword">index</span>, e);</span><br><span class="line">        <span class="hljs-keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//remove方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> E remove(<span class="hljs-keyword">int</span> <span class="hljs-keyword">index</span>) &#123;</span><br><span class="line">        rangeCheck(<span class="hljs-keyword">index</span>);</span><br><span class="line">        checkForComodification();</span><br><span class="line">        E result = parent.remove(parentOffset + <span class="hljs-keyword">index</span>);</span><br><span class="line">        <span class="hljs-keyword">this</span>.modCount = parent.modCount;</span><br><span class="line">        <span class="hljs-keyword">this</span>.size--;</span><br><span class="line">        <span class="hljs-keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该SubLsit是ArrayList的内部类，它与ArrayList一样，都是继承AbstractList和实现RandomAccess接口。同时也提供了get、set、add、remove等list常用的方法。但是它的构造函数有点特殊，在该构造函数中有两个地方需要注意：</p><p>1、this.parent = parent;而parent就是在前面传递过来的list，也就是说this.parent就是原始list的引用。</p><p>2、this.offset = offset + fromIndex;this.parentOffset = fromIndex;。同时在构造函数中它甚至将modCount（fail-fast机制）传递过来了。</p><p>我们再看get方法，在get方法中return ArrayList.this.elementData(offset + index);这段代码可以清晰表明get所返回就是原列表offset + index位置的元素。同样的道理还有add方法里面的：<br><figure class="highlight mipsasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parent.<span class="hljs-keyword">add(parentOffset </span>+ index, e)<span class="hljs-comment">;</span></span><br><span class="line">this.modCount = parent.modCount<span class="hljs-comment">;</span></span><br></pre></td></tr></table></figure></p><p>remove方法里面的<br><figure class="highlight qml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E result = <span class="hljs-built_in">parent</span>.remove(parentOffset + index);</span><br><span class="line"><span class="hljs-keyword">this</span>.modCount = <span class="hljs-built_in">parent</span>.modCount;</span><br></pre></td></tr></table></figure></p><p>诚然，到了这里我们可以判断subList返回的SubList同样也是AbstractList的子类，同时它的方法如get、set、add、remove等都是在原列表上面做操作，它并没有像subString一样生成一个新的对象。<label style="color:red">所以subList返回的只是原列表的一个视图，它所有的操作最终都会作用在原列表上。</label>字</p><p>因此，当我们使用子集合进行元素的修改操作时，会影响原有的list集合。所以在使用subList方法时，一定要想清楚，是否需要对子集合进行修改元素而不影响原有的list集合。<br>如果需要对子集合的元素进行修改操作而不需要影响原集合时，我们可以使用以下方法进行处理：<br><figure class="highlight dart hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">List</span>&lt;<span class="hljs-built_in">Object</span>&gt; tempList = <span class="hljs-keyword">new</span> ArrayList&lt;<span class="hljs-built_in">Object</span>&gt;(lists.subList(<span class="hljs-number">2</span>, lists.size()));</span><br></pre></td></tr></table></figure></p><h1 id="Fail-Fast机制"><a href="#Fail-Fast机制" class="headerlink" title="Fail-Fast机制"></a>Fail-Fast机制</h1><p>动机： 在 Java Collection 中，为了防止在某个线程在对 Collection 进行迭代时，其他线程对该 Collection 进行结构上的修改。换句话说，迭代器的快速失败行为仅用于检测代码的 bug。<br>　　<br>本质： Fail-Fast 是 Java 集合的一种错误检测机制。<br>　　<br>作用场景： 在使用迭代器时，Collection 的结构发生变化，抛出 ConcurrentModificationException 。当然，这并不能说明 Collection对象 已经被不同线程并发修改，因为如果单线程违反了规则，同样也有会抛出该异常。<br>　　<br>当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会触发fail-fast机制，抛出 ConcurrentModificationException 异常。在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。<br>　　<br>我们知道 fail-fast 产生的原因就在于：程序在对 collection 进行迭代时，某个线程对该 collection 在结构上对其做了修改。要想进一步了解 fail-fast 机制，我们首先要对 ConcurrentModificationException 异常有所了解。当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常。同时需要注意的是，该异常不会始终指出对象已经由不同线程并发修改，如果单线程违反了规则，同样也有可能会抛出改异常。诚然，迭代器的快速失败行为无法得到保证，它不能保证一定会出现该错误，但是快速失败操作会尽最大努力抛出 ConcurrentModificationException 异常，所以，为提高此类操作的正确性而编写一个依赖于此异常的程序是错误的做法，正确做法是：ConcurrentModificationException 应该仅用于检测 bug。<br>　　<br>下面我们以 ArrayList 为例进一步分析 fail-fast 产生的原因:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="hljs-keyword">int</span> cursor;  </span><br><span class="line">    <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>;  </span><br><span class="line">    <span class="hljs-keyword">int</span> expectedModCount = ArrayList.<span class="hljs-keyword">this</span>.modCount;  </span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;  </span><br><span class="line">        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.cursor != ArrayList.<span class="hljs-keyword">this</span>.size);  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;  </span><br><span class="line">        checkForComodification();  </span><br><span class="line">        <span class="hljs-comment">/** 省略此处代码 */</span>  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;  </span><br><span class="line">        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lastRet &lt; <span class="hljs-number">0</span>)  </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException();  </span><br><span class="line">        checkForComodification();  </span><br><span class="line">        <span class="hljs-comment">/** 省略此处代码 */</span>  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkForComodification</span><span class="hljs-params">()</span> </span>&#123;  </span><br><span class="line">        <span class="hljs-keyword">if</span> (ArrayList.<span class="hljs-keyword">this</span>.modCount == <span class="hljs-keyword">this</span>.expectedModCount)  </span><br><span class="line">            <span class="hljs-keyword">return</span>;  </span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从上面的源代码我们可以看出，迭代器在调用 next() 、 remove() 方法时都是调用 checkForComodification() 方法，该方法用于判断 “modCount == expectedModCount”：若不等，触发 fail-fast 机制，抛出 ConcurrentModificationException 异常。所以，要弄清楚为什么会产生 fail-fast 机制，我们就必须要弄明白 “modCount != expectedModCount” 什么时候发生，换句话说，他们的值在什么时候发生改变的。<br>　　<br>expectedModCount 是在 Itr 中定义的：“int expectedModCount = ArrayList.this.modCount;”，所以它的值是不可能会修改的，所以会变的就是 modCount。modCount 是在 AbstractList 中定义的，为全局变量：<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;</span><br></pre></td></tr></table></figure></p><p>从 ArrayList 源码中我们可以看出，我们直接或间接的通过 RemoveRange 、 trimToSize 和 ensureCapcity（add，remove，clear） 三个方法完成对 ArrayList 结构上的修改,所以 ArrayList 实例每当调用一次上面的方法，modCount 的值就递增一次。所以,我们这里可以判断:由于expectedModCount 的值与 modCount 的改变不同步，导致两者之间不等，从而触发fail-fast机制。我们可以考虑如下场景： </p><p>有两个线程（线程A，线程B），其中线程A负责遍历list、线程B修改list。线程A在遍历list过程的某个时候（此时expectedModCount = modCount=N），线程启动，同时线程B增加一个元素，这是modCount的值发生改变（modCount + 1 = N + 1）。线程A继续遍历执行next方法时，通告checkForComodification方法发现expectedModCount = N ，而modCount = N + 1，两者不等，这时触发 fail-fast机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ArrayList概述&quot;&gt;&lt;a href=&quot;#ArrayList概述&quot; class=&quot;headerlink&quot; title=&quot;ArrayList概述&quot;&gt;&lt;/a&gt;ArrayList概述&lt;/h1&gt;&lt;p&gt;ArrayList是实现List接口的动态数组，所谓动态就是它的大小
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="ArrayList" scheme="http://mindasoft.com/tags/ArrayList/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-ConcurrentHashMap源码剖析</title>
    <link href="http://mindasoft.com/2018/11/23/javase/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/23/javase/ConcurrentHashMap源码剖析/</id>
    <published>2018-11-23T09:29:37.000Z</published>
    <updated>2018-11-26T09:11:16.123Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ConcurrentHashMap简介"><a href="#ConcurrentHashMap简介" class="headerlink" title="ConcurrentHashMap简介"></a>ConcurrentHashMap简介</h1><p>因为多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p><p>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法时，其他线程访问HashTable的同步方法时，可能会进入阻塞或轮询状态。如线程1使用put进行添加元素，线程2不但不能使用put方法添加元素，并且也不能使用get方法来获取元素，所以竞争越激烈效率越低。</p><p>ConcurrentHashMap本质上是一个Segment数组，而一个Segment实例又包含若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。总的来说，ConcurrentHashMap的高效并发机制是通过以下三方面来保证的(具体细节见后文阐述)：</p><ul><li>通过锁分段技术保证并发环境下的写操作；</li><li>通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；</li><li>通过不加锁和加锁两种方案控制跨段操作的的安全性。</li></ul><p>ConcurrentHashMap类中包含两个静态内部类 HashEntry 和 Segment，其中 HashEntry 用来封装具体的K/V对，是个典型的四元组；Segment 用来充当锁的角色，每个 Segment 对象守护整个ConcurrentHashMap的若干个桶 (可以把Segment看作是一个小型的哈希表)，其中每个桶是由若干个 HashEntry 对象链接起来的链表。总的来说，一个ConcurrentHashMap实例中包含由若干个Segment实例组成的数组，而一个Segment实例又包含由若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。特别地，ConcurrentHashMap 在默认并发级别下会创建16个Segment对象的数组，如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。</p><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>ConcurrentHashMap 继承了AbstractMap并实现了ConcurrentMap接口，<br><figure class="highlight scala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcurrentHashMap&lt;K</span>, <span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap&lt;K</span>, <span class="hljs-title">V&gt;</span></span></span><br><span class="line"><span class="hljs-class">        <span class="hljs-title">implements</span> <span class="hljs-title">ConcurrentMap&lt;K</span>, <span class="hljs-title">V&gt;</span>, <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="成员变量定义"><a href="#成员变量定义" class="headerlink" title="成员变量定义"></a>成员变量定义</h1><p>与HashMap相比，ConcurrentHashMap 增加了两个属性用于定位段，分别是 segmentMask 和 segmentShift。此外，不同于HashMap的是，ConcurrentHashMap底层结构是一个Segment数组，而不是Object数组，具体源码如下：<br><figure class="highlight zephir hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * Mask value for indexing into segments. The upper bits of a</span></span><br><span class="line"><span class="hljs-comment">  * key's hash code are used to choose the segment.</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentMask;  <span class="hljs-comment">// 用于定位段，大小等于segments数组的大小减 1，是不可变的</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * Shift value for indexing within segments.</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> segmentShift;    <span class="hljs-comment">// 用于定位段，大小等于32(hash值的位数)减去对segments的大小取以2为底的对数值，是不可变的</span></span><br><span class="line"></span><br><span class="line"> <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">  * The segments, each of which is a specialized hash table</span></span><br><span class="line"><span class="hljs-comment">  */</span></span><br><span class="line"> <span class="hljs-keyword">final</span> Segment&lt;K,V&gt;[] segments;   <span class="hljs-comment">// ConcurrentHashMap的底层结构是一个Segment数组</span></span><br></pre></td></tr></table></figure></p><h1 id="ConcurrentHashMap-的数据结构"><a href="#ConcurrentHashMap-的数据结构" class="headerlink" title="ConcurrentHashMap 的数据结构"></a>ConcurrentHashMap 的数据结构</h1><p>本质上，ConcurrentHashMap就是一个Segment数组，而一个Segment实例则是一个小的哈希表。由于Segment类继承于ReentrantLock类，从而使得Segment对象能充当锁的角色，这样，每个 Segment对象就可以守护整个ConcurrentHashMap的若干个桶，其中每个桶是由若干个HashEntry 对象链接起来的链表。<label style="color:red">通过使用段(Segment)将ConcurrentHashMap划分为不同的部分，ConcurrentHashMap就可以使用不同的锁来控制对哈希表的不同部分的修改，从而允许多个修改操作并发进行, 这正是ConcurrentHashMap锁分段技术的核心内涵。</label>进一步地，如果把整个ConcurrentHashMap看作是一个父哈希表的话，那么每个Segment就可以看作是一个子哈希表，如下图所示：<br><img src="/images/ConcurrentHashMap示意图.jpg" alt="ConcurrentHashMap示意图"><br>注意，假设ConcurrentHashMap一共分为2^n个段，每个段中有2^m个桶，那么段的定位方式是将key的hash值的高n位与(2^n-1)相与。在定位到某个段后，再将key的hash值的低m位与(2^m-1)相与，定位到具体的桶位。</p><h2 id="段的定义：Segment"><a href="#段的定义：Segment" class="headerlink" title="段的定义：Segment"></a>段的定义：Segment</h2><label style="color:red">Segment 类继承于 ReentrantLock 类，从而使得 Segment 对象能充当锁的角色。</label><br>每个 Segment 对象用来守护它的成员对象 table 中包含的若干个桶。table 是一个由 HashEntry 对象组成的链表数组，table 数组的每一个数组成员就是一个桶。<br><br>在Segment类中，count 变量是一个计数器，它表示每个 Segment 对象管理的 table 数组包含的 HashEntry 对象的个数，也就是 Segment 中包含的 HashEntry 对象的总数。特别需要注意的是，之所以在每个 Segment 对象中包含一个计数器，而不是在 ConcurrentHashMap 中使用全局的计数器，是对 ConcurrentHashMap 并发性的考虑：<label style="color:red">因为这样当需要更新计数器时，不用锁定整个ConcurrentHashMap。</label>事实上，每次对段进行结构上的改变，如在段中进行增加/删除节点(修改节点的值不算结构上的改变)，都要更新count的值，此外，在JDK的实现中每次读取操作开始都要先读取count的值。特别需要注意的是，count是volatile的，这使得对count的任何更新对其它线程都是立即可见的。modCount用于统计段结构改变的次数，主要是为了检测对多个段进行遍历过程中某个段是否发生改变，这一点具体在谈到跨段操作时会详述。threashold用来表示段需要进行重哈希的阈值。loadFactor表示段的负载因子，其值等同于ConcurrentHashMap的负载因子的值。table是一个典型的链表数组，而且也是volatile的，这使得对table的任何更新对其它线程也都是立即可见的。段(Segment)的定义如下：<br><figure class="highlight zephir hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Segments are specialized versions of hash tables.  This</span></span><br><span class="line"><span class="hljs-comment">     * subclasses from ReentrantLock opportunistically, just to</span></span><br><span class="line"><span class="hljs-comment">     * simplify some locking and avoid separate construction.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Segment</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * The number of elements in this segment's region.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        transient volatile <span class="hljs-keyword">int</span> count;    <span class="hljs-comment">// Segment中元素的数量，可见的</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * Number of updates that alter the size of the table. This is</span></span><br><span class="line"><span class="hljs-comment">         * used during bulk-read methods to make sure they see a</span></span><br><span class="line"><span class="hljs-comment">         * consistent snapshot: If modCounts change during a traversal</span></span><br><span class="line"><span class="hljs-comment">         * of segments computing size or checking containsValue, then</span></span><br><span class="line"><span class="hljs-comment">         * we might have an inconsistent view of state so (usually)</span></span><br><span class="line"><span class="hljs-comment">         * must retry.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        transient <span class="hljs-keyword">int</span> modCount;  <span class="hljs-comment">//对count的大小造成影响的操作的次数（比如put或者remove操作）</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * The table is rehashed when its size exceeds this threshold.</span></span><br><span class="line"><span class="hljs-comment">         * (The value of this field is always &lt;tt&gt;(int)(capacity *</span></span><br><span class="line"><span class="hljs-comment">         * loadFactor)&lt;/tt&gt;.)</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        transient <span class="hljs-keyword">int</span> threshold;      <span class="hljs-comment">// 阈值，段中元素的数量超过这个值就会对Segment进行扩容</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * The per-segment table.</span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        transient volatile HashEntry&lt;K,V&gt;[] table;  <span class="hljs-comment">// 链表数组</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">         * The load factor for the hash table.  Even though this value</span></span><br><span class="line"><span class="hljs-comment">         * is same for all segments, it is replicated to avoid needing</span></span><br><span class="line"><span class="hljs-comment">         * links to outer object.</span></span><br><span class="line"><span class="hljs-comment">         * <span class="hljs-doctag">@serial</span></span></span><br><span class="line"><span class="hljs-comment">         */</span></span><br><span class="line">        <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;  <span class="hljs-comment">// 段的负载因子，其值等同于ConcurrentHashMap的负载因子</span></span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br>我们知道，ConcurrentHashMap允许多个修改(写)操作并发进行，其关键在于使用了锁分段技术，它使用了不同的锁来控制对哈希表的不同部分进行的修改(写)，而 ConcurrentHashMap 内部使用段(Segment)来表示这些不同的部分。实际上，每个段实质上就是一个小的哈希表，每个段都有自己的锁(Segment 类继承了 ReentrantLock 类)。这样，只要多个修改(写)操作发生在不同的段上，它们就可以并发进行。下图是依次插入 ABC 三个 HashEntry节点后，Segment 的结构示意图：<br><img src="/images/segment.jpg" alt="Segment"><br><br>## 基本元素：HashEntry<br>HashEntry用来封装具体的键值对，是个典型的四元组。与HashMap中的Entry类似，HashEntry也包括同样的四个域，分别是key、hash、value和next。<label style="color:red">不同的是，在HashEntry类中，key，hash和next域都被声明为final的，value域被volatile所修饰，因此HashEntry对象几乎是不可变的，这是ConcurrentHashmap读操作并不需要加锁的一个重要原因。</label>next域被声明为final本身就意味着我们不能从hash链的中间或尾部添加或删除节点，因为这需要修改next引用值，因此所有的节点的修改只能从头部开始。对于put操作，可以一律添加到Hash链的头部。但是对于remove操作，可能需要从中间删除一个节点，这就需要将要删除节点的前面所有节点整个复制(重新new)一遍，最后一个节点指向要删除结点的下一个结点(这在谈到ConcurrentHashMap的删除操作时还会详述)。特别地，<label style="color:red">由于value域被volatile修饰，所以其可以确保被读线程读到最新的值，这是ConcurrentHashmap读操作并不需要加锁的另一个重要原因。</label>实际上，ConcurrentHashMap完全允许多个读操作并发进行，读操作并不需要加锁。HashEntry代表hash链中的一个节点，其结构如下所示：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">    * ConcurrentHashMap 中的 HashEntry 类</span></span><br><span class="line"><span class="hljs-comment">    * </span></span><br><span class="line"><span class="hljs-comment">    * ConcurrentHashMap list entry. Note that this is never exported</span></span><br><span class="line"><span class="hljs-comment">    * out as a user-visible Map.Entry.</span></span><br><span class="line"><span class="hljs-comment">    *</span></span><br><span class="line"><span class="hljs-comment">    * Because the value field is volatile, not final, it is legal wrt</span></span><br><span class="line"><span class="hljs-comment">    * the Java Memory Model for an unsynchronized reader to see null</span></span><br><span class="line"><span class="hljs-comment">    * instead of initial value when read via a data race.  Although a</span></span><br><span class="line"><span class="hljs-comment">    * reordering leading to this is not likely to ever actually</span></span><br><span class="line"><span class="hljs-comment">    * occur, the Segment.readValueUnderLock method is used as a</span></span><br><span class="line"><span class="hljs-comment">    * backup in case a null (pre-initialized) value is ever seen in</span></span><br><span class="line"><span class="hljs-comment">    * an unsynchronized access method.</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashEntry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">final</span> K key;                       <span class="hljs-comment">// 声明 key 为 final 的</span></span><br><span class="line">      <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;                   <span class="hljs-comment">// 声明 hash 值为 final 的</span></span><br><span class="line">      <span class="hljs-keyword">volatile</span> V value;                <span class="hljs-comment">// 声明 value 被volatile所修饰</span></span><br><span class="line">      <span class="hljs-keyword">final</span> HashEntry&lt;K,V&gt; next;      <span class="hljs-comment">// 声明 next 为 final 的</span></span><br><span class="line"></span><br><span class="line">       HashEntry(K key, <span class="hljs-keyword">int</span> hash, HashEntry&lt;K,V&gt; next, V value) &#123;</span><br><span class="line">           <span class="hljs-keyword">this</span>.key = key;</span><br><span class="line">           <span class="hljs-keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="hljs-keyword">this</span>.next = next;</span><br><span class="line">           <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)</span><br><span class="line">       <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> &lt;K,V&gt; HashEntry&lt;K,V&gt;[] newArray(<span class="hljs-keyword">int</span> i) &#123;</span><br><span class="line">       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HashEntry[i];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><br><br>与HashMap类似，在ConcurrentHashMap中，如果在散列时发生碰撞，也会将碰撞的 HashEntry 对象链成一个链表。由于HashEntry的next域是final的，所以新节点只能在链表的表头处插入。下图是在一个空桶中依次插入 A，B，C 三个 HashEntry 对象后的结构图(由于只能在表头插入，所以链表中节点的顺序和插入的顺序相反)：<br><img src="/images/HashEntry.jpg" alt="HashEntry"><br><br><br># 方法<br><br>## 构造方法<br>ConcurrentHashMap 一共提供了五个构造函数，其中默认无参的构造函数和参数为Map的构造函数 为 Java Collection Framework 规范的推荐实现，其余三个构造函数则是 ConcurrentHashMap 专门提供的。<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 构造一个具有默认初始容量(16)、默认负载因子(0.75)和默认并发级别(16)的空ConcurrentHashMap</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(Math.max((<span class="hljs-keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="hljs-number">1</span>,</span><br><span class="line">                  DEFAULT_INITIAL_CAPACITY),</span><br><span class="line">         DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">    putAll(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR, DEFAULT_CONCURRENCY_LEVEL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(initialCapacity, loadFactor, DEFAULT_CONCURRENCY_LEVEL);  <span class="hljs-comment">// 默认并发级别为16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ConcurrentHashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor, <span class="hljs-keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (!(loadFactor &gt; <span class="hljs-number">0</span>) || initialCapacity &lt; <span class="hljs-number">0</span> || concurrencyLevel &lt;= <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)              </span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="hljs-keyword">int</span> sshift = <span class="hljs-number">0</span>;            <span class="hljs-comment">// 大小为 lg(ssize) </span></span><br><span class="line">    <span class="hljs-keyword">int</span> ssize = <span class="hljs-number">1</span>;            <span class="hljs-comment">// 段的数目，segments数组的大小(2的幂次方)</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="hljs-number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    segmentShift = <span class="hljs-number">32</span> - sshift;      <span class="hljs-comment">// 用于定位段</span></span><br><span class="line">    segmentMask = ssize - <span class="hljs-number">1</span>;      <span class="hljs-comment">// 用于定位段</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.segments = Segment.newArray(ssize);   <span class="hljs-comment">// 创建segments数组</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="hljs-keyword">int</span> c = initialCapacity / ssize;    <span class="hljs-comment">// 总的桶数/总的段数</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="hljs-keyword">int</span> cap = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 每个段所拥有的桶的数目(2的幂次方)</span></span><br><span class="line">    <span class="hljs-keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.segments.length; ++i)      <span class="hljs-comment">// 初始化segments数组</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.segments[i] = <span class="hljs-keyword">new</span> Segment&lt;K,V&gt;(cap, loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在这里，我们提到了三个非常重要的参数：<label style="color:red">初始容量、负载因子 和 并发级别</label>，这三个参数是影响ConcurrentHashMap性能的重要参数。从上述源码我们可以看出，ConcurrentHashMap 也正是通过initialCapacity、loadFactor和concurrencyLevel这三个参数进行构造并初始化segments数组、段偏移量segmentShift、段掩码segmentMask和每个segment的。<br><br>## 并发写操作<br>在ConcurrentHashMap中，线程对映射表做读操作时，一般情况下不需要加锁就可以完成，对容器做结构性修改的操作(比如，put操作、remove操作等)才需要加锁。典型结构性修改操作包括put、remove和clear，下面我们首先以put操作为例说明对ConcurrentHashMap做结构性修改的过程。ConcurrentHashMap的put操作对应的源码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="hljs-keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="hljs-keyword">return</span> segmentFor(hash).put(key, hash, value, <span class="hljs-keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>从上面的源码我们看到，ConcurrentHashMap不同于HashMap，<label style="color:red">它既不允许key值为null，也不允许value值为null。</label>此外，我们还可以看到，实际上我们对ConcurrentHashMap的put操作被ConcurrentHashMap委托给特定的段来实现。也就是说，当我们向ConcurrentHashMap中put一个Key/Value对时，首先会获得Key的哈希值并对其再次哈希，然后根据最终的hash值定位到这条记录所应该插入的段，定位段的segmentFor()方法源码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">final</span> Segment&lt;K,V&gt; <span class="hljs-title">segmentFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>segmentFor()方法根据传入的hash值向右无符号右移segmentShift位，然后和segmentMask进行与操作就可以定位到特定的段。在这里，假设Segment的数量(segments数组的长度)是2的n次方(Segment的数量总是2的倍数，具体见构造函数的实现)，那么segmentShift的值就是32-n(hash值的位数是32)，而segmentMask的值就是2^n-1（写成二进制的形式就是n个1）。进一步地，我们就可以得出以下结论：<label style="color:red">根据key的hash值的高n位就可以确定元素到底在哪一个Segment中。</label>紧接着，调用这个段的put()方法来将目标Key/Value对插到段中，段的put()方法的源码如下所示：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">V <span class="hljs-title">put</span><span class="hljs-params">(K key, <span class="hljs-keyword">int</span> hash, V value, <span class="hljs-keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    lock();    <span class="hljs-comment">// 上锁</span></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> c = count;</span><br><span class="line">        <span class="hljs-keyword">if</span> (c++ &gt; threshold) <span class="hljs-comment">// ensure capacity</span></span><br><span class="line">            rehash();</span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = table;    <span class="hljs-comment">// table是Volatile的</span></span><br><span class="line">        <span class="hljs-keyword">int</span> index = hash &amp; (tab.length - <span class="hljs-number">1</span>);    <span class="hljs-comment">// 定位到段中特定的桶</span></span><br><span class="line">        HashEntry&lt;K,V&gt; first = tab[index];   <span class="hljs-comment">// first指向桶中链表的表头</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = first;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 检查该桶中是否存在相同key的结点</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span> &amp;&amp; (e.hash != hash || !key.equals(e.key)))  </span><br><span class="line">            e = e.next;</span><br><span class="line"></span><br><span class="line">        V oldValue;</span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-comment">// 该桶中存在相同key的结点</span></span><br><span class="line">            oldValue = e.value;</span><br><span class="line">            <span class="hljs-keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.value = value;        <span class="hljs-comment">// 更新value值</span></span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;         <span class="hljs-comment">// 该桶中不存在相同key的结点</span></span><br><span class="line">            oldValue = <span class="hljs-keyword">null</span>;</span><br><span class="line">            ++modCount;     <span class="hljs-comment">// 结构性修改，modCount加1</span></span><br><span class="line">            tab[index] = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(key, hash, first, value);  <span class="hljs-comment">// 创建HashEntry并将其链到表头</span></span><br><span class="line">            count = c;      <span class="hljs-comment">//write-volatile，count值的更新一定要放在最后一步(volatile变量)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> oldValue;    <span class="hljs-comment">// 返回旧值(该桶中不存在相同key的结点，则返回null)</span></span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        unlock();      <span class="hljs-comment">// 在finally子句中解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>从源码中首先可以知道，ConcurrentHashMap对Segment的put操作是加锁完成的。我们已经知道Segment是ReentrantLock的子类，因此Segment本身就是一种可重入的Lock，所以我们可以直接调用其继承而来的lock()方法和unlock()方法对代码进行上锁/解锁。需要注意的是，这里的加锁操作是针对某个具体的Segment，锁定的也是该Segment而不是整个ConcurrentHashMap。因为插入键/值对操作只是在这个Segment包含的某个桶中完成，不需要锁定整个ConcurrentHashMap。因此，其他写线程对另外15个Segment的加锁并不会因为当前线程对这个Segment的加锁而阻塞。故而 <label style="color:red">相比较于 HashTable 和由同步包装器包装的HashMap每次只能有一个线程执行读或写操作，ConcurrentHashMap 在并发访问性能上有了质的提高。在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设置为 16），及任意数量线程的读操作。</label><p>在将Key/Value对插入到Segment之前，首先会检查本次插入会不会导致Segment中元素的数量超过阈值threshold，如果会，那么就先对Segment进行扩容和重哈希操作，然后再进行插入。重哈希操作暂且不表，稍后详述。第8和第9行的操作就是定位到段中特定的桶并确定链表头部的位置。第12行的while循环用于检查该桶中是否存在相同key的结点，如果存在，就直接更新value值；如果没有找到，则进入21行生成一个新的HashEntry并且把它链到该桶中链表的表头，然后再更新count的值(由于count是volatile变量，所以count值的更新一定要放在最后一步)。</p><p>到此为止，除了重哈希操作，ConcurrentHashMap的put操作已经介绍完了。此外，在ConcurrentHashMap中，修改操作还包括putAll()和replace()。其中，putAll()操作就是多次调用put方法，而replace()操作实现要比put()操作简单得多，此不赘述。</p><h2 id="重哈希操作"><a href="#重哈希操作" class="headerlink" title="重哈希操作"></a>重哈希操作</h2><p>上面叙述到，在ConcurrentHashMap中使用put操作插入Key/Value对之前，首先会检查本次插入会不会导致Segment中节点数量超过阈值threshold，如果会，那么就先对Segment进行扩容和重哈希操作。特别需要注意的是，ConcurrentHashMap的重哈希实际上是对ConcurrentHashMap的某个段的重哈希，因此ConcurrentHashMap的每个段所包含的桶位自然也就不尽相同。针对段进行rehash()操作的源码如下</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;    <span class="hljs-comment">// 扩容前的table</span></span><br><span class="line">    <span class="hljs-keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="hljs-keyword">if</span> (oldCapacity &gt;= MAXIMUM_CAPACITY)   <span class="hljs-comment">// 已经扩到最大容量，直接返回</span></span><br><span class="line">        <span class="hljs-keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">     * Reclassify nodes in each list to new Map.  Because we are</span></span><br><span class="line"><span class="hljs-comment">     * using power-of-two expansion, the elements from each bin</span></span><br><span class="line"><span class="hljs-comment">     * must either stay at same index, or move with a power of two</span></span><br><span class="line"><span class="hljs-comment">     * offset. We eliminate unnecessary node creation by catching</span></span><br><span class="line"><span class="hljs-comment">     * cases where old nodes can be reused because their next</span></span><br><span class="line"><span class="hljs-comment">     * fields won't change. Statistically, at the default</span></span><br><span class="line"><span class="hljs-comment">     * threshold, only about one-sixth of them need cloning when</span></span><br><span class="line"><span class="hljs-comment">     * a table doubles. The nodes they replace will be garbage</span></span><br><span class="line"><span class="hljs-comment">     * collectable as soon as they are no longer referenced by any</span></span><br><span class="line"><span class="hljs-comment">     * reader thread that may be in the midst of traversing table</span></span><br><span class="line"><span class="hljs-comment">     * right now.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// 新创建一个table，其容量是原来的2倍</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable = HashEntry.newArray(oldCapacity&lt;&lt;<span class="hljs-number">1</span>);   </span><br><span class="line">    threshold = (<span class="hljs-keyword">int</span>)(newTable.length * loadFactor);   <span class="hljs-comment">// 新的阈值</span></span><br><span class="line">    <span class="hljs-keyword">int</span> sizeMask = newTable.length - <span class="hljs-number">1</span>;     <span class="hljs-comment">// 用于定位桶</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="hljs-comment">// We need to guarantee that any existing reads of old Map can</span></span><br><span class="line">        <span class="hljs-comment">//  proceed. So we cannot yet null out each bin.</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];  <span class="hljs-comment">// 依次指向旧table中的每个桶的链表表头</span></span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-comment">// 旧table的该桶中链表不为空</span></span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="hljs-keyword">int</span> idx = e.hash &amp; sizeMask;   <span class="hljs-comment">// 重哈希已定位到新桶</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (next == <span class="hljs-keyword">null</span>)    <span class="hljs-comment">//  旧table的该桶中只有一个节点</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="hljs-keyword">else</span> &#123;    </span><br><span class="line">                <span class="hljs-comment">// Reuse trailing consecutive sequence at same slot</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="hljs-keyword">int</span> lastIdx = idx;</span><br><span class="line">                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="hljs-keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="hljs-comment">// 寻找k值相同的子链，该子链尾节点与父链的尾节点必须是同一个</span></span><br><span class="line">                    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// JDK直接将子链lastRun放到newTable[lastIdx]桶中</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line"></span><br><span class="line">                <span class="hljs-comment">// 对该子链之前的结点，JDK会挨个遍历并把它们复制到新桶中</span></span><br><span class="line">                <span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    <span class="hljs-keyword">int</span> k = p.hash &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="hljs-keyword">new</span> HashEntry&lt;K,V&gt;(p.key, p.hash,</span><br><span class="line">                                                     n, p.value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    table = newTable;   <span class="hljs-comment">// 扩容完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实JDK官方的注释已经解释的很清楚了。由于扩容是按照2的幂次方进行的，所以扩展前在同一个桶中的元素，现在要么还是在原来的序号的桶里，或者就是原来的序号再加上一个2的幂次方，就这两种选择。根据本文前面对HashEntry的介绍，我们知道链接指针next是final的，因此看起来我们好像只能把该桶的HashEntry链中的每个节点复制到新的桶中(这意味着我们要重新创建每个节点)，但事实上JDK对其做了一定的优化。因为在理论上原桶里的HashEntry链可能存在一条子链，这条子链上的节点都会被重哈希到同一个新的桶中，这样我们只要拿到该子链的头结点就可以直接把该子链放到新的桶中，从而避免了一些节点不必要的创建，提升了一定的效率。因此，JDK为了提高效率，它会首先去查找这样的一个子链，而且这个子链的尾节点必须与原hash链的尾节点是同一个，那么就只需要把这个子链的头结点放到新的桶中，其后面跟的一串子节点自然也就连接上了。对于这个子链头结点之前的结点，JDK会挨个遍历并把它们复制到新桶的链头(只能在表头插入元素)中。特别地，我们注意这段代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">     last != <span class="hljs-keyword">null</span>;</span><br><span class="line">     last = last.next) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">    <span class="hljs-keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">        lastIdx = k;</span><br><span class="line">        lastRun = last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">newTable[lastIdx] = lastRun;</span><br></pre></td></tr></table></figure></p><p>在该代码段中，JDK直接将子链lastRun放到newTable[lastIdx]桶中，难道这个操作不会覆盖掉newTable[lastIdx]桶中原有的元素么？事实上，这种情形时不可能出现的，因为桶newTable[lastIdx]在子链添加进去之前压根就不会有节点存在，这还是因为table的大小是按照2的幂次方的方式去扩展的。假设原来table的大小是2^k大小，那么现在新table的大小是2^(k+1)大小，而定位桶的方式是:<br><figure class="highlight nix hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="hljs-attr">sizeMask</span> = newTable.length - <span class="hljs-number">1</span>，即 <span class="hljs-attr">sizeMask</span> = <span class="hljs-number">11</span>...<span class="hljs-number">1</span>，共k+<span class="hljs-number">1</span>个<span class="hljs-number">1</span>。</span><br><span class="line">int <span class="hljs-attr">idx</span> = e.hash &amp; sizeMask;</span><br></pre></td></tr></table></figure></p><p>因此这样得到的idx实际上就是key的hash值的低k+1位的值，而原table的sizeMask也全是1的二进制，不过总共是k位，那么原table的idx就是key的hash值的低k位的值。所以，如果元素的hashcode的第k+1位是0，那么元素在新桶的序号就是和原桶的序号是相等的；如果第k+1位的值是1，那么元素在新桶的序号就是原桶的序号加上2^k。因此，JDK直接将子链lastRun放到newTable[lastIdx]桶中就没问题了，因为newTable中新序号处此时肯定是空的。</p><h2 id="读取操作"><a href="#读取操作" class="headerlink" title="读取操作"></a>读取操作</h2><p>与put操作类似，当我们从ConcurrentHashMap中查询一个指定Key的键值对时，首先会定位其应该存在的段，然后查询请求委托给这个段进行处理，源码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">    <span class="hljs-keyword">return</span> segmentFor(hash).get(key, hash);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们紧接着研读Segment中get操作的源码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(Object key, <span class="hljs-keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (count != <span class="hljs-number">0</span>) &#123;            <span class="hljs-comment">// read-volatile，首先读 count 变量</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = getFirst(hash);   <span class="hljs-comment">// 获取桶中链表头结点</span></span><br><span class="line">        <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; key.equals(e.key)) &#123;    <span class="hljs-comment">// 查找链中是否存在指定Key的键值对</span></span><br><span class="line">                V v = e.value;</span><br><span class="line">                <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>)  <span class="hljs-comment">// 如果读到value域不为 null，直接返回</span></span><br><span class="line">                    <span class="hljs-keyword">return</span> v;   </span><br><span class="line">                <span class="hljs-comment">// 如果读到value域为null，说明发生了重排序，加锁后重新读取</span></span><br><span class="line">                <span class="hljs-keyword">return</span> readValueUnderLock(e); <span class="hljs-comment">// recheck</span></span><br><span class="line">            &#125;</span><br><span class="line">            e = e.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  <span class="hljs-comment">// 如果不存在，直接返回null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>了解了ConcurrentHashMap的put操作后，上述源码就很好理解了。但是有一个情况需要特别注意，就是链中存在指定Key的键值对并且其对应的Value值为null的情况。在剖析ConcurrentHashMap的put操作时，我们就知道ConcurrentHashMap不同于HashMap，它既不允许key值为null，也不允许value值为null。但是，此处怎么会存在键值对存在且的Value值为null的情形呢？JDK官方给出的解释是，这种情形发生的场景是：初始化HashEntry时发生的指令重排序导致的，也就是在HashEntry初始化完成之前便返回了它的引用。这时，JDK给出的解决之道就是加锁重读，源码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">V <span class="hljs-title">readValueUnderLock</span><span class="hljs-params">(HashEntry&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">            lock();</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> e.value;</span><br><span class="line">            &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>在ConcurrentHashMap进行存取时，首先会定位到具体的段，然后通过对具体段的存取来完成对整个ConcurrentHashMap的存取。特别地，无论是ConcurrentHashMap的读操作还是写操作都具有很高的性能：在进行读操作时不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ConcurrentHashMap简介&quot;&gt;&lt;a href=&quot;#ConcurrentHashMap简介&quot; class=&quot;headerlink&quot; title=&quot;ConcurrentHashMap简介&quot;&gt;&lt;/a&gt;ConcurrentHashMap简介&lt;/h1&gt;&lt;p&gt;因为
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="ConcurrentHashMap" scheme="http://mindasoft.com/tags/ConcurrentHashMap/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-Hashtable源码剖析</title>
    <link href="http://mindasoft.com/2018/11/23/javase/Hashtable%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/23/javase/Hashtable源码剖析/</id>
    <published>2018-11-23T08:00:08.000Z</published>
    <updated>2018-11-23T08:20:49.481Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hashtable简介"><a href="#Hashtable简介" class="headerlink" title="Hashtable简介"></a>Hashtable简介</h1><p>Hashtable同样是基于哈希表实现的，同样每个元素是一个key-value对，其内部也是通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br>Hashtable也是JDK1.0引入的类，是线程安全的，能用于多线程环境中。<br>Hashtable同样实现了Serializable接口，它支持序列化，实现了Cloneable接口，能被克隆。</p><h1 id="HashTable源码剖析"><a href="#HashTable源码剖析" class="headerlink" title="HashTable源码剖析"></a>HashTable源码剖析</h1><p>Hashtable的源码的很多实现都与HashMap差不多，源码如下（加入了比较详细的注释）：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-keyword">package</span> java.util;    </span><br><span class="line"><span class="hljs-keyword">import</span> java.io.*;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hashtable</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;    </span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">Dictionary</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;    </span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 保存key-value的数组。    </span></span><br><span class="line">    <span class="hljs-comment">// Hashtable同样采用单链表解决冲突，每一个Entry本质上是一个单向链表    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Entry[] table;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable中键值对的数量    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> count;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> threshold;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 加载因子    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> loadFactor;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable被改变的次数，用于fail-fast机制的实现    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount = <span class="hljs-number">0</span>;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 序列版本号    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1421746759512286392L</span>;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 指定“容量大小”和“加载因子”的构造函数    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Capacity: "</span>+    </span><br><span class="line">                                               initialCapacity);    </span><br><span class="line">        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal Load: "</span>+loadFactor);    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-keyword">if</span> (initialCapacity==<span class="hljs-number">0</span>)    </span><br><span class="line">            initialCapacity = <span class="hljs-number">1</span>;    </span><br><span class="line">        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;    </span><br><span class="line">        table = <span class="hljs-keyword">new</span> Entry[initialCapacity];    </span><br><span class="line">        threshold = (<span class="hljs-keyword">int</span>)(initialCapacity * loadFactor);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 指定“容量大小”的构造函数    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">this</span>(initialCapacity, <span class="hljs-number">0.75f</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 默认构造函数。    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// 默认构造函数，指定的容量大小是11；加载因子是0.75    </span></span><br><span class="line">        <span class="hljs-keyword">this</span>(<span class="hljs-number">11</span>, <span class="hljs-number">0.75f</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 包含“子Map”的构造函数    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Hashtable</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">this</span>(Math.max(<span class="hljs-number">2</span>*t.size(), <span class="hljs-number">11</span>), <span class="hljs-number">0.75f</span>);    </span><br><span class="line">        <span class="hljs-comment">// 将“子Map”的全部元素都添加到Hashtable中    </span></span><br><span class="line">        putAll(t);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> count;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> count == <span class="hljs-number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回“所有key”的枚举对象    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Enumeration&lt;K&gt; <span class="hljs-title">keys</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.&lt;K&gt;getEnumeration(KEYS);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回“所有value”的枚举对象    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Enumeration&lt;V&gt; <span class="hljs-title">elements</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.&lt;V&gt;getEnumeration(VALUES);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 判断Hashtable是否包含“值(value)”    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object value)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">//注意，Hashtable中的value不能是null，    </span></span><br><span class="line">        <span class="hljs-comment">// 若是null的话，抛出异常!    </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 从后向前遍历table数组中的元素(Entry)    </span></span><br><span class="line">        <span class="hljs-comment">// 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value    </span></span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = tab.length ; i-- &gt; <span class="hljs-number">0</span> ;) &#123;    </span><br><span class="line">            <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">                <span class="hljs-keyword">if</span> (e.value.equals(value)) &#123;    </span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsValue</span><span class="hljs-params">(Object value)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> contains(value);    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 判断Hashtable是否包含key    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsKey</span><span class="hljs-params">(Object key)</span> </span>&#123;    </span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        <span class="hljs-comment">//计算hash值，直接用key的hashCode代替  </span></span><br><span class="line">        <span class="hljs-keyword">int</span> hash = key.hashCode();      </span><br><span class="line">        <span class="hljs-comment">// 计算在数组中的索引值   </span></span><br><span class="line">        <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">        <span class="hljs-comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;    </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回key对应的value，没有的话返回null    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">get</span><span class="hljs-params">(Object key)</span> </span>&#123;    </span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">        <span class="hljs-comment">// 计算索引值，    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">        <span class="hljs-comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;    </span><br><span class="line">                <span class="hljs-keyword">return</span> e.value;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 调整Hashtable的长度，将长度变成原来的2倍+1   </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rehash</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">int</span> oldCapacity = table.length;    </span><br><span class="line">        Entry[] oldMap = table;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">//创建新容量大小的Entry数组  </span></span><br><span class="line">        <span class="hljs-keyword">int</span> newCapacity = oldCapacity * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;    </span><br><span class="line">        Entry[] newMap = <span class="hljs-keyword">new</span> Entry[newCapacity];    </span><br><span class="line">   </span><br><span class="line">        modCount++;    </span><br><span class="line">        threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);    </span><br><span class="line">        table = newMap;    </span><br><span class="line">          </span><br><span class="line">        <span class="hljs-comment">//将“旧的Hashtable”中的元素复制到“新的Hashtable”中  </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = oldCapacity ; i-- &gt; <span class="hljs-number">0</span> ;) &#123;    </span><br><span class="line">            <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; old = oldMap[i] ; old != <span class="hljs-keyword">null</span> ; ) &#123;    </span><br><span class="line">                Entry&lt;K,V&gt; e = old;    </span><br><span class="line">                old = old.next;    </span><br><span class="line">                <span class="hljs-comment">//重新计算index  </span></span><br><span class="line">                <span class="hljs-keyword">int</span> index = (e.hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % newCapacity;    </span><br><span class="line">                e.next = newMap[index];    </span><br><span class="line">                newMap[index] = e;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 将“key-value”添加到Hashtable中    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">put</span><span class="hljs-params">(K key, V value)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// Hashtable中不能插入value为null的元素！！！    </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 若“Hashtable中已存在键为key的键值对”，    </span></span><br><span class="line">        <span class="hljs-comment">// 则用“新的value”替换“旧的value”    </span></span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">        <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;    </span><br><span class="line">                V old = e.value;    </span><br><span class="line">                e.value = value;    </span><br><span class="line">                <span class="hljs-keyword">return</span> old;    </span><br><span class="line">                &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 若“Hashtable中不存在键为key的键值对”，  </span></span><br><span class="line">        <span class="hljs-comment">// 将“修改统计数”+1    </span></span><br><span class="line">        modCount++;    </span><br><span class="line">        <span class="hljs-comment">//  若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子)    </span></span><br><span class="line">        <span class="hljs-comment">//  则调整Hashtable的大小    </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (count &gt;= threshold) &#123;  </span><br><span class="line">            rehash();    </span><br><span class="line">   </span><br><span class="line">            tab = table;    </span><br><span class="line">            index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">//将新的key-value对插入到tab[index]处（即链表的头结点）  </span></span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];           </span><br><span class="line">        tab[index] = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);    </span><br><span class="line">        count++;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 删除Hashtable中键为key的元素    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V <span class="hljs-title">remove</span><span class="hljs-params">(Object key)</span> </span>&#123;    </span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">        <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">          </span><br><span class="line">        <span class="hljs-comment">//从table[index]链表中找出要删除的节点，并删除该节点。  </span></span><br><span class="line">        <span class="hljs-comment">//因为是单链表，因此要保留带删节点的前一个节点，才能有效地删除节点  </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="hljs-keyword">null</span> ; e != <span class="hljs-keyword">null</span> ; prev = e, e = e.next) &#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;    </span><br><span class="line">                modCount++;    </span><br><span class="line">                <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">                    prev.next = e.next;    </span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;    </span><br><span class="line">                    tab[index] = e.next;    </span><br><span class="line">                &#125;    </span><br><span class="line">                count--;    </span><br><span class="line">                V oldValue = e.value;    </span><br><span class="line">                e.value = <span class="hljs-keyword">null</span>;    </span><br><span class="line">                <span class="hljs-keyword">return</span> oldValue;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 将“Map(t)”的中全部元素逐一添加到Hashtable中    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putAll</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet())    </span><br><span class="line">            put(e.getKey(), e.getValue());    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 清空Hashtable    </span></span><br><span class="line">    <span class="hljs-comment">// 将Hashtable的table数组的值全部设为null    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        Entry tab[] = table;    </span><br><span class="line">        modCount++;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = tab.length; --index &gt;= <span class="hljs-number">0</span>; )    </span><br><span class="line">            tab[index] = <span class="hljs-keyword">null</span>;    </span><br><span class="line">        count = <span class="hljs-number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 克隆一个Hashtable，并以Object的形式返回。    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;    </span><br><span class="line">            Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) <span class="hljs-keyword">super</span>.clone();    </span><br><span class="line">            t.table = <span class="hljs-keyword">new</span> Entry[table.length];    </span><br><span class="line">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = table.length ; i-- &gt; <span class="hljs-number">0</span> ; ) &#123;    </span><br><span class="line">                t.table[i] = (table[i] != <span class="hljs-keyword">null</span>)    </span><br><span class="line">                ? (Entry&lt;K,V&gt;) table[i].clone() : <span class="hljs-keyword">null</span>;    </span><br><span class="line">            &#125;    </span><br><span class="line">            t.keySet = <span class="hljs-keyword">null</span>;    </span><br><span class="line">            t.entrySet = <span class="hljs-keyword">null</span>;    </span><br><span class="line">            t.values = <span class="hljs-keyword">null</span>;    </span><br><span class="line">            t.modCount = <span class="hljs-number">0</span>;    </span><br><span class="line">            <span class="hljs-keyword">return</span> t;    </span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;     </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">int</span> max = size() - <span class="hljs-number">1</span>;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (max == -<span class="hljs-number">1</span>)    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-string">"&#123;&#125;"</span>;    </span><br><span class="line">   </span><br><span class="line">        StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();    </span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator();    </span><br><span class="line">   </span><br><span class="line">        sb.append(<span class="hljs-string">'&#123;'</span>);    </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; ; i++) &#123;    </span><br><span class="line">            Map.Entry&lt;K,V&gt; e = it.next();    </span><br><span class="line">            K key = e.getKey();    </span><br><span class="line">            V value = e.getValue();    </span><br><span class="line">            sb.append(key   == <span class="hljs-keyword">this</span> ? <span class="hljs-string">"(this Map)"</span> : key.toString());    </span><br><span class="line">            sb.append(<span class="hljs-string">'='</span>);    </span><br><span class="line">            sb.append(value == <span class="hljs-keyword">this</span> ? <span class="hljs-string">"(this Map)"</span> : value.toString());    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">if</span> (i == max)    </span><br><span class="line">                <span class="hljs-keyword">return</span> sb.append(<span class="hljs-string">'&#125;'</span>).toString();    </span><br><span class="line">            sb.append(<span class="hljs-string">", "</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 获取Hashtable的枚举类对象    </span></span><br><span class="line">    <span class="hljs-comment">// 若Hashtable的实际大小为0,则返回“空枚举类”对象；    </span></span><br><span class="line">    <span class="hljs-comment">// 否则，返回正常的Enumerator的对象。   </span></span><br><span class="line">    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Enumeration&lt;T&gt; <span class="hljs-title">getEnumeration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> (Enumeration&lt;T&gt;)emptyEnumerator;    </span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Enumerator&lt;T&gt;(type, <span class="hljs-keyword">false</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 获取Hashtable的迭代器    </span></span><br><span class="line">    <span class="hljs-comment">// 若Hashtable的实际大小为0,则返回“空迭代器”对象；    </span></span><br><span class="line">    <span class="hljs-comment">// 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口)    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> &lt;T&gt; <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">getIterator</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> (Iterator&lt;T&gt;) emptyIterator;    </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Enumerator&lt;T&gt;(type, <span class="hljs-keyword">true</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable的“key的集合”。它是一个Set，没有重复元素    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Set&lt;K&gt; keySet = <span class="hljs-keyword">null</span>;    </span><br><span class="line">    <span class="hljs-comment">// Hashtable的“key-value的集合”。它是一个Set，没有重复元素    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="hljs-keyword">null</span>;    </span><br><span class="line">    <span class="hljs-comment">// Hashtable的“key-value的集合”。它是一个Collection，可以有重复元素    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Collection&lt;V&gt; values = <span class="hljs-keyword">null</span>;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回一个被synchronizedSet封装后的KeySet对象    </span></span><br><span class="line">    <span class="hljs-comment">// synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;K&gt; <span class="hljs-title">keySet</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (keySet == <span class="hljs-keyword">null</span>)    </span><br><span class="line">            keySet = Collections.synchronizedSet(<span class="hljs-keyword">new</span> KeySet(), <span class="hljs-keyword">this</span>);    </span><br><span class="line">        <span class="hljs-keyword">return</span> keySet;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable的Key的Set集合。    </span></span><br><span class="line">    <span class="hljs-comment">// KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">K</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;K&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> getIterator(KEYS);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> count;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> containsKey(o);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> Hashtable.<span class="hljs-keyword">this</span>.remove(o) != <span class="hljs-keyword">null</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            Hashtable.<span class="hljs-keyword">this</span>.clear();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回一个被synchronizedSet封装后的EntrySet对象    </span></span><br><span class="line">    <span class="hljs-comment">// synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步    </span></span><br><span class="line">    <span class="hljs-keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (entrySet==<span class="hljs-keyword">null</span>)    </span><br><span class="line">            entrySet = Collections.synchronizedSet(<span class="hljs-keyword">new</span> EntrySet(), <span class="hljs-keyword">this</span>);    </span><br><span class="line">        <span class="hljs-keyword">return</span> entrySet;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable的Entry的Set集合。    </span></span><br><span class="line">    <span class="hljs-comment">// EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntrySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;&gt; </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> getIterator(ENTRIES);    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(Map.Entry&lt;K,V&gt; o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.add(o);    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 查找EntrySet中是否包含Object(0)    </span></span><br><span class="line">        <span class="hljs-comment">// 首先，在table中找到o对应的Entry链表    </span></span><br><span class="line">        <span class="hljs-comment">// 然后，查找Entry链表中是否存在Object    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))    </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">            Map.Entry entry = (Map.Entry)o;    </span><br><span class="line">            Object key = entry.getKey();    </span><br><span class="line">            Entry[] tab = table;    </span><br><span class="line">            <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">            <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">for</span> (Entry e = tab[index]; e != <span class="hljs-keyword">null</span>; e = e.next)    </span><br><span class="line">                <span class="hljs-keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry))    </span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 删除元素Object(0)    </span></span><br><span class="line">        <span class="hljs-comment">// 首先，在table中找到o对应的Entry链表  </span></span><br><span class="line">        <span class="hljs-comment">// 然后，删除链表中的元素Object    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">remove</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))    </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">            Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;    </span><br><span class="line">            K key = entry.getKey();    </span><br><span class="line">            Entry[] tab = table;    </span><br><span class="line">            <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">            <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="hljs-keyword">null</span>; e != <span class="hljs-keyword">null</span>;    </span><br><span class="line">                 prev = e, e = e.next) &#123;    </span><br><span class="line">                <span class="hljs-keyword">if</span> (e.hash==hash &amp;&amp; e.equals(entry)) &#123;    </span><br><span class="line">                    modCount++;    </span><br><span class="line">                    <span class="hljs-keyword">if</span> (prev != <span class="hljs-keyword">null</span>)    </span><br><span class="line">                        prev.next = e.next;    </span><br><span class="line">                    <span class="hljs-keyword">else</span>   </span><br><span class="line">                        tab[index] = e.next;    </span><br><span class="line">   </span><br><span class="line">                    count--;    </span><br><span class="line">                    e.value = <span class="hljs-keyword">null</span>;    </span><br><span class="line">                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> count;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            Hashtable.<span class="hljs-keyword">this</span>.clear();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 返回一个被synchronizedCollection封装后的ValueCollection对象    </span></span><br><span class="line">    <span class="hljs-comment">// synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;V&gt; <span class="hljs-title">values</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">    <span class="hljs-keyword">if</span> (values==<span class="hljs-keyword">null</span>)    </span><br><span class="line">        values = Collections.synchronizedCollection(<span class="hljs-keyword">new</span> ValueCollection(),    </span><br><span class="line">                                                        <span class="hljs-keyword">this</span>);    </span><br><span class="line">        <span class="hljs-keyword">return</span> values;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable的value的Collection集合。    </span></span><br><span class="line">    <span class="hljs-comment">// ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ValueCollection</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractCollection</span>&lt;<span class="hljs-title">V</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;V&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">return</span> getIterator(VALUES);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> count;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> containsValue(o);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            Hashtable.<span class="hljs-keyword">this</span>.clear();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 重新equals()函数    </span></span><br><span class="line">    <span class="hljs-comment">// 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map))    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (t.size() != size())    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;    </span><br><span class="line">            <span class="hljs-comment">// 通过迭代器依次取出当前Hashtable的key-value键值对    </span></span><br><span class="line">            <span class="hljs-comment">// 并判断该键值对，存在于Hashtable中。    </span></span><br><span class="line">            <span class="hljs-comment">// 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。    </span></span><br><span class="line">            Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();    </span><br><span class="line">            <span class="hljs-keyword">while</span> (i.hasNext()) &#123;    </span><br><span class="line">                Map.Entry&lt;K,V&gt; e = i.next();    </span><br><span class="line">                K key = e.getKey();    </span><br><span class="line">                V value = e.getValue();    </span><br><span class="line">                <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">                    <span class="hljs-keyword">if</span> (!(t.get(key)==<span class="hljs-keyword">null</span> &amp;&amp; t.containsKey(key)))    </span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">                &#125; <span class="hljs-keyword">else</span> &#123;    </span><br><span class="line">                    <span class="hljs-keyword">if</span> (!value.equals(t.get(key)))    </span><br><span class="line">                        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">                &#125;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassCastException unused)   &#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NullPointerException unused) &#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 计算Entry的hashCode    </span></span><br><span class="line">    <span class="hljs-comment">// 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。    </span></span><br><span class="line">    <span class="hljs-comment">// 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">int</span> h = <span class="hljs-number">0</span>;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span> || loadFactor &lt; <span class="hljs-number">0</span>)    </span><br><span class="line">            <span class="hljs-keyword">return</span> h;  <span class="hljs-comment">// Returns zero    </span></span><br><span class="line">   </span><br><span class="line">        loadFactor = -loadFactor;  <span class="hljs-comment">// Mark hashCode computation in progress    </span></span><br><span class="line">        Entry[] tab = table;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; tab.length; i++)    </span><br><span class="line">            <span class="hljs-keyword">for</span> (Entry e = tab[i]; e != <span class="hljs-keyword">null</span>; e = e.next)    </span><br><span class="line">                h += e.key.hashCode() ^ e.value.hashCode();    </span><br><span class="line">        loadFactor = -loadFactor;  <span class="hljs-comment">// Mark hashCode computation complete    </span></span><br><span class="line">   </span><br><span class="line">        <span class="hljs-keyword">return</span> h;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// java.io.Serializable的写入函数    </span></span><br><span class="line">    <span class="hljs-comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject</span><span class="hljs-params">(java.io.ObjectOutputStream s)</span>    </span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> IOException    </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// Write out the length, threshold, loadfactor    </span></span><br><span class="line">        s.defaultWriteObject();    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// Write out length, count of elements and then the key/value objects    </span></span><br><span class="line">        s.writeInt(table.length);    </span><br><span class="line">        s.writeInt(count);    </span><br><span class="line">        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> index = table.length-<span class="hljs-number">1</span>; index &gt;= <span class="hljs-number">0</span>; index--) &#123;    </span><br><span class="line">            Entry entry = table[index];    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">while</span> (entry != <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">            s.writeObject(entry.key);    </span><br><span class="line">            s.writeObject(entry.value);    </span><br><span class="line">            entry = entry.next;    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// java.io.Serializable的读取函数：根据写入方式读出    </span></span><br><span class="line">    <span class="hljs-comment">// 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出    </span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span>    </span></span><br><span class="line"><span class="hljs-function">         <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException    </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// Read in the length, threshold, and loadfactor    </span></span><br><span class="line">        s.defaultReadObject();    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// Read the original length of the array and number of elements    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> origlength = s.readInt();    </span><br><span class="line">        <span class="hljs-keyword">int</span> elements = s.readInt();    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// Compute new size with a bit of room 5% to grow but    </span></span><br><span class="line">        <span class="hljs-comment">// no larger than the original size.  Make the length    </span></span><br><span class="line">        <span class="hljs-comment">// odd if it's large enough, this helps distribute the entries.    </span></span><br><span class="line">        <span class="hljs-comment">// Guard against the length ending up zero, that's not valid.    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> length = (<span class="hljs-keyword">int</span>)(elements * loadFactor) + (elements / <span class="hljs-number">20</span>) + <span class="hljs-number">3</span>;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (length &gt; elements &amp;&amp; (length &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>)    </span><br><span class="line">            length--;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (origlength &gt; <span class="hljs-number">0</span> &amp;&amp; length &gt; origlength)    </span><br><span class="line">            length = origlength;    </span><br><span class="line">   </span><br><span class="line">        Entry[] table = <span class="hljs-keyword">new</span> Entry[length];    </span><br><span class="line">        count = <span class="hljs-number">0</span>;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// Read the number of elements and then all the key/value objects    </span></span><br><span class="line">        <span class="hljs-keyword">for</span> (; elements &gt; <span class="hljs-number">0</span>; elements--) &#123;    </span><br><span class="line">            K key = (K)s.readObject();    </span><br><span class="line">            V value = (V)s.readObject();    </span><br><span class="line">                <span class="hljs-comment">// synch could be eliminated for performance    </span></span><br><span class="line">                reconstitutionPut(table, key, value);    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-keyword">this</span>.table = table;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reconstitutionPut</span><span class="hljs-params">(Entry[] tab, K key, V value)</span>    </span></span><br><span class="line"><span class="hljs-function">        <span class="hljs-keyword">throws</span> StreamCorruptedException    </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.io.StreamCorruptedException();    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-comment">// Makes sure the key is not already in the hashtable.    </span></span><br><span class="line">        <span class="hljs-comment">// This should not happen in deserialized version.    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> hash = key.hashCode();    </span><br><span class="line">        <span class="hljs-keyword">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">        <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> java.io.StreamCorruptedException();    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="hljs-comment">// Creates the new entry.    </span></span><br><span class="line">        Entry&lt;K,V&gt; e = tab[index];    </span><br><span class="line">        tab[index] = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);    </span><br><span class="line">        count++;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Hashtable的Entry节点，它本质上是一个单向链表。    </span></span><br><span class="line">    <span class="hljs-comment">// 也因此，我们才能推断出Hashtable是由拉链法实现的散列表    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// 哈希值    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> hash;    </span><br><span class="line">        K key;    </span><br><span class="line">        V value;    </span><br><span class="line">        <span class="hljs-comment">// 指向的下一个Entry，即链表的下一个节点    </span></span><br><span class="line">        Entry&lt;K,V&gt; next;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 构造函数    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Entry</span><span class="hljs-params">(<span class="hljs-keyword">int</span> hash, K key, V value, Entry&lt;K,V&gt; next)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.hash = hash;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.key = key;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.value = value;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.next = next;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, value,    </span><br><span class="line">                  (next==<span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : (Entry&lt;K,V&gt;) next.clone()));    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> K <span class="hljs-title">getKey</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> key;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> value;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 设置value。若value是null，则抛出异常。    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">setValue</span><span class="hljs-params">(V value)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>)    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    </span><br><span class="line">   </span><br><span class="line">            V oldValue = <span class="hljs-keyword">this</span>.value;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.value = value;    </span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 覆盖equals()方法，判断两个Entry是否相等。    </span></span><br><span class="line">        <span class="hljs-comment">// 若两个Entry的key和value都相等，则认为它们相等。    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object o)</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (!(o <span class="hljs-keyword">instanceof</span> Map.Entry))    </span><br><span class="line">                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">            Map.Entry e = (Map.Entry)o;    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">return</span> (key==<span class="hljs-keyword">null</span> ? e.getKey()==<span class="hljs-keyword">null</span> : key.equals(e.getKey())) &amp;&amp;    </span><br><span class="line">               (value==<span class="hljs-keyword">null</span> ? e.getValue()==<span class="hljs-keyword">null</span> : value.equals(e.getValue()));    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> hash ^ (value==<span class="hljs-keyword">null</span> ? <span class="hljs-number">0</span> : value.hashCode());    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> key.toString()+<span class="hljs-string">"="</span>+value.toString();    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> KEYS = <span class="hljs-number">0</span>;    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> VALUES = <span class="hljs-number">1</span>;    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ENTRIES = <span class="hljs-number">2</span>;    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enumerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Enumeration</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;    </span><br><span class="line">        <span class="hljs-comment">// 指向Hashtable的table    </span></span><br><span class="line">        Entry[] table = Hashtable.<span class="hljs-keyword">this</span>.table;    </span><br><span class="line">        <span class="hljs-comment">// Hashtable的总的大小    </span></span><br><span class="line">        <span class="hljs-keyword">int</span> index = table.length;    </span><br><span class="line">        Entry&lt;K,V&gt; entry = <span class="hljs-keyword">null</span>;    </span><br><span class="line">        Entry&lt;K,V&gt; lastReturned = <span class="hljs-keyword">null</span>;    </span><br><span class="line">        <span class="hljs-keyword">int</span> type;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志    </span></span><br><span class="line">        <span class="hljs-comment">// iterator为true，表示它是迭代器；否则，是枚举类。    </span></span><br><span class="line">        <span class="hljs-keyword">boolean</span> iterator;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。    </span></span><br><span class="line">        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> expectedModCount = modCount;    </span><br><span class="line">   </span><br><span class="line">        Enumerator(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">boolean</span> iterator) &#123;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.type = type;    </span><br><span class="line">            <span class="hljs-keyword">this</span>.iterator = iterator;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasMoreElements</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            Entry&lt;K,V&gt; e = entry;    </span><br><span class="line">            <span class="hljs-keyword">int</span> i = index;    </span><br><span class="line">            Entry[] t = table;    </span><br><span class="line">            <span class="hljs-comment">/* Use locals for faster loop iteration */</span>   </span><br><span class="line">            <span class="hljs-keyword">while</span> (e == <span class="hljs-keyword">null</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) &#123;    </span><br><span class="line">                e = t[--i];    </span><br><span class="line">            &#125;    </span><br><span class="line">            entry = e;    </span><br><span class="line">            index = i;    </span><br><span class="line">            <span class="hljs-keyword">return</span> e != <span class="hljs-keyword">null</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 获取下一个元素    </span></span><br><span class="line">        <span class="hljs-comment">// 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式”    </span></span><br><span class="line">        <span class="hljs-comment">// 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。    </span></span><br><span class="line">        <span class="hljs-comment">// 然后，依次向后遍历单向链表Entry。    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">nextElement</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            Entry&lt;K,V&gt; et = entry;    </span><br><span class="line">            <span class="hljs-keyword">int</span> i = index;    </span><br><span class="line">            Entry[] t = table;    </span><br><span class="line">            <span class="hljs-comment">/* Use locals for faster loop iteration */</span>   </span><br><span class="line">            <span class="hljs-keyword">while</span> (et == <span class="hljs-keyword">null</span> &amp;&amp; i &gt; <span class="hljs-number">0</span>) &#123;    </span><br><span class="line">                et = t[--i];    </span><br><span class="line">            &#125;    </span><br><span class="line">            entry = et;    </span><br><span class="line">            index = i;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (et != <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">                Entry&lt;K,V&gt; e = lastReturned = entry;    </span><br><span class="line">                entry = e.next;    </span><br><span class="line">                <span class="hljs-keyword">return</span> type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e);    </span><br><span class="line">            &#125;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"Hashtable Enumerator"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 迭代器Iterator的判断是否存在下一个元素    </span></span><br><span class="line">        <span class="hljs-comment">// 实际上，它是调用的hasMoreElements()    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> hasMoreElements();    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 迭代器获取下一个元素    </span></span><br><span class="line">        <span class="hljs-comment">// 实际上，它是调用的nextElement()    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (modCount != expectedModCount)    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    </span><br><span class="line">            <span class="hljs-keyword">return</span> nextElement();    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 迭代器的remove()接口。    </span></span><br><span class="line">        <span class="hljs-comment">// 首先，它在table数组中找出要删除元素所在的Entry，    </span></span><br><span class="line">        <span class="hljs-comment">// 然后，删除单向链表Entry中的元素。    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">if</span> (!iterator)    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();    </span><br><span class="line">            <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-keyword">null</span>)    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Hashtable Enumerator"</span>);    </span><br><span class="line">            <span class="hljs-keyword">if</span> (modCount != expectedModCount)    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    </span><br><span class="line">   </span><br><span class="line">            <span class="hljs-keyword">synchronized</span>(Hashtable.<span class="hljs-keyword">this</span>) &#123;    </span><br><span class="line">                Entry[] tab = Hashtable.<span class="hljs-keyword">this</span>.table;    </span><br><span class="line">                <span class="hljs-keyword">int</span> index = (lastReturned.hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">   </span><br><span class="line">                <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index], prev = <span class="hljs-keyword">null</span>; e != <span class="hljs-keyword">null</span>;    </span><br><span class="line">                     prev = e, e = e.next) &#123;    </span><br><span class="line">                    <span class="hljs-keyword">if</span> (e == lastReturned) &#123;    </span><br><span class="line">                        modCount++;    </span><br><span class="line">                        expectedModCount++;    </span><br><span class="line">                        <span class="hljs-keyword">if</span> (prev == <span class="hljs-keyword">null</span>)    </span><br><span class="line">                            tab[index] = e.next;    </span><br><span class="line">                        <span class="hljs-keyword">else</span>   </span><br><span class="line">                            prev.next = e.next;    </span><br><span class="line">                        count--;    </span><br><span class="line">                        lastReturned = <span class="hljs-keyword">null</span>;    </span><br><span class="line">                        <span class="hljs-keyword">return</span>;    </span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();    </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Enumeration emptyEnumerator = <span class="hljs-keyword">new</span> EmptyEnumerator();    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Iterator emptyIterator = <span class="hljs-keyword">new</span> EmptyIterator();    </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 空枚举类    </span></span><br><span class="line">    <span class="hljs-comment">// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyEnumerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Enumeration</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    </span><br><span class="line">   </span><br><span class="line">        EmptyEnumerator() &#123;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 空枚举类的hasMoreElements() 始终返回false    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasMoreElements</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-comment">// 空枚举类的nextElement() 抛出异常    </span></span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">nextElement</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"Hashtable Enumerator"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">    <span class="hljs-comment">// 空迭代器    </span></span><br><span class="line">    <span class="hljs-comment">// 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。    </span></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmptyIterator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">Object</span>&gt; </span>&#123;    </span><br><span class="line">   </span><br><span class="line">        EmptyIterator() &#123;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException(<span class="hljs-string">"Hashtable Iterator"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;    </span><br><span class="line">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Hashtable Iterator"</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">   </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="几点总结"><a href="#几点总结" class="headerlink" title="几点总结"></a>几点总结</h1><p>针对Hashtable，我们同样给出几点比较重要的总结，但要结合与HashMap的比较来总结。<br>1、二者的存储结构和解决冲突的方法都是相同的。</p><p>2、HashTable在不指定容量的情况下的默认容量为11，而HashMap为16，Hashtable不要求底层数组的容量一定要为2的整数次幂，而HashMap则要求一定为2的整数次幂。</p><p>3、Hashtable中key和value都不允许为null，而HashMap中key和value都允许为null（key只能有一个为null，而value则可以有多个为null）。但是如果在Hashtable中有类似put(null,null)的操作，编译同样可以通过，因为key和value都是Object类型，但运行时会抛出NullPointerException异常，这是JDK的规范规定的。我们来看下ContainsKey方法和ContainsValue的源码：</p><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 判断Hashtable是否包含“值(value)”    </span></span><br><span class="line"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-built_in">boolean</span> contains(<span class="hljs-keyword">Object</span> value) &#123;    </span><br><span class="line">     <span class="hljs-comment">//注意，Hashtable中的value不能是null，    </span></span><br><span class="line">     <span class="hljs-comment">// 若是null的话，抛出异常!    </span></span><br><span class="line">     <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;    </span><br><span class="line">         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    </span><br><span class="line">     &#125;    </span><br><span class="line">  </span><br><span class="line">     <span class="hljs-comment">// 从后向前遍历table数组中的元素(Entry)    </span></span><br><span class="line">     <span class="hljs-comment">// 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value    </span></span><br><span class="line">     Entry tab[] = table;    </span><br><span class="line">     <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = tab.length ; i-- &gt; <span class="hljs-number">0</span> ;) &#123;    </span><br><span class="line">         <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[i] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">             <span class="hljs-keyword">if</span> (e.value.equals(value)) &#123;    </span><br><span class="line">                 <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">             &#125;    </span><br><span class="line">         &#125;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line"> &#125;    </span><br><span class="line">  </span><br><span class="line"> <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> containsValue(<span class="hljs-keyword">Object</span> value) &#123;    </span><br><span class="line">     <span class="hljs-keyword">return</span> contains(value);    </span><br><span class="line"> &#125;    </span><br><span class="line">  </span><br><span class="line"> <span class="hljs-comment">// 判断Hashtable是否包含key    </span></span><br><span class="line"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-built_in">boolean</span> containsKey(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;    </span><br><span class="line">     Entry tab[] = table;    </span><br><span class="line">/计算hash值，直接用<span class="hljs-built_in">key</span>的hashCode代替  </span><br><span class="line">     <span class="hljs-built_in">int</span> hash = <span class="hljs-built_in">key</span>.hashCode();      </span><br><span class="line">     <span class="hljs-comment">// 计算在数组中的索引值   </span></span><br><span class="line">     <span class="hljs-built_in">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;    </span><br><span class="line">     <span class="hljs-comment">// 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素    </span></span><br><span class="line">     <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = tab[index] ; e != <span class="hljs-keyword">null</span> ; e = e.next) &#123;    </span><br><span class="line">         <span class="hljs-keyword">if</span> ((e.hash == hash) &amp;&amp; e.<span class="hljs-built_in">key</span>.equals(<span class="hljs-built_in">key</span>)) &#123;    </span><br><span class="line">             <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    </span><br><span class="line">         &#125;    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>很明显，如果value为null，会直接抛出NullPointerException异常，但源码中并没有对key是否为null判断，有点小不解！不过NullPointerException属于RuntimeException异常，是可以由JVM自动抛出的，也许对key的值在JVM中有所限制吧。</p><p>4、Hashtable扩容时，将容量变为原来的2倍加1，而HashMap扩容时，将容量变为原来的2倍。</p><p>5、Hashtable计算hash值，直接用key的hashCode()，而HashMap重新计算了key的hash值，Hashtable在求hash值对应的位置索引时，用取模运算，而HashMap在求位置索引时，则用与运算，且这里一般先用hash&amp;0x7FFFFFFF后，再对length取模，&amp;0x7FFFFFFF的目的是为了将负的hash值转化为正值，因为hash值有可能为负数，而&amp;0x7FFFFFFF后，只有符号外改变，而后面的位都不变。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Hashtable简介&quot;&gt;&lt;a href=&quot;#Hashtable简介&quot; class=&quot;headerlink&quot; title=&quot;Hashtable简介&quot;&gt;&lt;/a&gt;Hashtable简介&lt;/h1&gt;&lt;p&gt;Hashtable同样是基于哈希表实现的，同样每个元素是一个key-
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="Hashtable" scheme="http://mindasoft.com/tags/Hashtable/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-HashMap源码剖析</title>
    <link href="http://mindasoft.com/2018/11/23/javase/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/23/javase/HashMap源码剖析/</id>
    <published>2018-11-23T07:29:37.000Z</published>
    <updated>2018-11-27T03:08:50.605Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap简介"><a href="#HashMap简介" class="headerlink" title="HashMap简介"></a>HashMap简介</h1><p>HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br>HashMap是非线程安全的，只是用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。<br>HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆。</p><h1 id="哈希的相关概念"><a href="#哈希的相关概念" class="headerlink" title="哈希的相关概念"></a>哈希的相关概念</h1><p>Hash 就是把任意长度的输入(又叫做预映射， pre-image)，通过哈希算法，变换成固定长度的输出(通常是整型)，该输出就是哈希值。这种转换是一种<label style="color:red">压缩映射</label>，也就是说，散列值的空间通常远小于输入的空间。<label style="color:red">不同的输入可能会散列成相同的输出，从而不可能从散列值来唯一的确定输入值。简单的说，就是一种将任意长度的消息压缩到某一固定长度的息摘要函数。</label></p><h1 id="哈希的应用：数据结构"><a href="#哈希的应用：数据结构" class="headerlink" title="哈希的应用：数据结构"></a>哈希的应用：数据结构</h1><p>我们知道，<label style="color:red">数组的特点是：寻址容易，插入和删除困难；而链表的特点是：寻址困难，插入和删除容易。</label>那么我们能不能综合两者的特性，做出一种寻址容易，插入和删除也容易的数据结构呢？答案是肯定的，这就是我们要提起的哈希表。事实上，哈希表有多种不同的实现方法，我们接下来解释的是最经典的一种方法 ——<label style="color:red"><strong>拉链法</strong></label>，我们可以将其理解为<label style="color:red"><strong>链表的数组</strong></label>，如下图所示：<br><img src="/images/拉链哈希表.jpg" alt="拉链哈希表"><br>我们可以从上图看到，左边很明显是个数组，数组的每个成员是一个链表。该数据结构所容纳的所有元素均包含一个指针，用于元素间的链接。我们根据元素的自身特征把元素分配到不同的链表中去，反过来我们也正是通过这些特征找到正确的链表，再从链表中找出正确的元素。其中，根据元素特征计算元素数组下标的方法就是 哈希算法。</p><p>总的来说，哈希表适合用作快速查找、删除的基本数据结构，通常需要总数据量可以放入内存。在使用哈希表时，有以下几个关键点：</p><ul><li>hash 函数（哈希算法）的选择：针对不同的对象(字符串、整数等)具体的哈希方法；</li><li>碰撞处理：常用的有两种方式，一种是open hashing，即 &gt;拉链法；另一种就是 closed hashing，即开地址法(opened addressing)。</li></ul><h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1><p>1、首先要清楚HashMap的存储结构，如下图所示：<br><img src="/images/hashmap.jpeg" alt="HashMap的存储结构"><br>我们知道，在Java中最常用的两种结构是 数组 和 链表，几乎所有的数据结构都可以利用这两种来组合实现，HashMap 就是这种应用的一个典型。</p><p>图中，紫色部分即为哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中。</p><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><p>HashMap实现了Map接口，并继承 AbstractMap 抽象类，其中 Map 接口定义了键值映射规则。和 AbstractCollection抽象类在 Collection 族的作用类似， AbstractMap 抽象类提供了 Map 接口的骨干实现，以最大限度地减少实现Map接口所需的工作。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMap</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span></span><br><span class="line"><span class="hljs-class">    <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><figure class="highlight gradle hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 默认的初始容量（容量为HashMap中槽的数目）是16，且实际容量必须是2的整数次幂。    </span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">16</span>;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）    </span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// 默认加载因子为0.75   </span></span><br><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// 存储数据的Entry数组，长度是2的幂。    </span></span><br><span class="line"><span class="hljs-comment">// HashMap采用链表法解决冲突，每一个Entry本质上是一个单向链表    </span></span><br><span class="line"><span class="hljs-keyword">transient</span> Entry[] table;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// HashMap的底层数组中已用槽的数量    </span></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">size</span>;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）    </span></span><br><span class="line"><span class="hljs-keyword">int</span> threshold;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// 加载因子实际大小    </span></span><br><span class="line"><span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> loadFactor;    </span><br><span class="line">   </span><br><span class="line"><span class="hljs-comment">// HashMap被改变的次数    </span></span><br><span class="line"><span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>HashMap 一共提供了四个构造函数，其中 默认无参的构造函数 和 参数为Map的构造函数 为 Java Collection Framework 规范的推荐实现，其余两个构造函数则是 HashMap 专门提供的。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Constructs an empty HashMap with the default initial capacity</span></span><br><span class="line"><span class="hljs-comment">     * (16) and the default load factor (0.75).</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//负载因子:用于衡量的是一个散列表的空间的使用程度</span></span><br><span class="line">        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//HashMap进行扩容的阈值，它的值等于 HashMap 的容量乘以负载因子</span></span><br><span class="line">        threshold = (<span class="hljs-keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// HashMap的底层实现仍是数组，只是数组的每一项都是一条链</span></span><br><span class="line">        table = <span class="hljs-keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line"></span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>该构造函数意在构造一个具有&gt; 默认初始容量 (16) 和 默认负载因子(0.75) 的空 HashMap。</p><p>从上述源码中我们可以看出，每次新建一个HashMap时，都会初始化一个Entry类型的table数组。<br><figure class="highlight axapta hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">final</span> K key;     <span class="hljs-comment">// 键值对的键</span></span><br><span class="line">    V value;        <span class="hljs-comment">// 键值对的值</span></span><br><span class="line">    Entry&lt;K,V&gt; next;    <span class="hljs-comment">// 下一个节点</span></span><br><span class="line">    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> hash;     <span class="hljs-comment">// hash(key.hashCode())方法的返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment">     * Creates new entry.</span></span><br><span class="line"><span class="hljs-comment">     */</span></span><br><span class="line">    Entry(<span class="hljs-keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;     <span class="hljs-comment">// Entry 的构造函数</span></span><br><span class="line">        value = v;</span><br><span class="line">        next = n;</span><br><span class="line">        key = k;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，Entry为HashMap的内部类，实现了 Map.Entry 接口，其包含了键key、值value、下一个节点next，以及hash值四个属性。事实上，Entry 是构成哈希表的基石，是哈希表所存储的元素的具体形式。、</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//初始容量不能小于 0</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//初始容量不能超过 2^30</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//负载因子不能小于 0            </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// HashMap 的容量必须是2的幂次方，超过 initialCapacity 的最小 2^n </span></span><br><span class="line">    <span class="hljs-keyword">int</span> capacity = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">        capacity &lt;&lt;= <span class="hljs-number">1</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//负载因子</span></span><br><span class="line">    <span class="hljs-keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//设置HashMap的容量极限，当HashMap的容量达到该极限时就会进行自动扩容操作</span></span><br><span class="line">    threshold = (<span class="hljs-keyword">int</span>)(capacity * loadFactor);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// HashMap的底层实现仍是数组，只是数组的每一项都是一条链</span></span><br><span class="line">    table = <span class="hljs-keyword">new</span> Entry[capacity];</span><br><span class="line">    init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数意在构造一个 指定初始容量 和 指定负载因子的空 HashMap</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);  <span class="hljs-comment">// 直接调用上述构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造函数意在构造一个指定初始容量和默认负载因子 (0.75)的空 HashMap</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// 初始容量不小于 16 </span></span><br><span class="line">        <span class="hljs-keyword">this</span>(Math.max((<span class="hljs-keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="hljs-number">1</span>,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>该构造函数意在构造一个与指定 Map 具有相同映射的 HashMap，其 初始容量不小于 16 (具体依赖于指定Map的大小)，负载因子是 0.75</p><p>在这里，我们提到了两个非常重要的参数：初始容量 和 负载因子，这两个参数是影响HashMap性能的重要参数。其中，容量表示哈希表中桶的数量 (table 数组的大小)，初始容量是创建哈希表时桶的数量；负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。</p><p>对于使用 拉链法的哈希表来说，查找一个元素的平均时间是 O(1+a)，a 指的是链的长度，是一个常数。特别地，若负载因子越大，那么对空间的利用更充分，但查找效率的也就越低；若负载因子越小，那么哈希表的数据将越稀疏，对空间造成的浪费也就越严重。系统默认负载因子为 0.75，这是时间和空间成本上一种折衷，一般情况下我们是无需修改的。</p><p>构造方法中提到了两个很重要的参数：初始容量和加载因子。这两个参数是影响HashMap性能的重要参数，<label style="color:red">其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（从构造函数中可以看出，如果不指明，则默认为16），加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 resize 操作（即扩容）。<br>下面说下加载因子，如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），对空间造成严重浪费。如果我们在构造方法中不指定，则系统默认加载因子为0.75，这是一个比较理想的值，一般情况下我们是无需修改的。<br>另外，无论我们指定的容量为多少，构造方法都会将实际容量设为不小于指定容量的2的次方的一个数，且最大值不能超过2的30次方</label></p><h2 id="快速存储"><a href="#快速存储" class="headerlink" title="快速存储"></a>快速存储</h2><p>在HashMap中，我们最常用的两个操作就是：put(Key,Value) 和 get(Key)。我们都知道，HashMap中的Key是唯一的，那它是如何保证唯一性的呢？我们首先想到的是用equals比较，没错，这样可以实现，但随着元素的增多，put 和 get 的效率将越来越低，这里的时间复杂度是O(n)。也就是说，假如 HashMap 有1000个元素，那么 put时就需要比较 1000 次，这是相当耗时的，远达不到HashMap快速存取的目的。实际上，HashMap 很少会用到equals方法，因为其内通过一个哈希表管理所有元素，利用哈希算法可以快速的存取元素。当我们调用put方法存值时，HashMap首先会调用Key的hashCode方法，然后基于此获取Key哈希码，通过哈希码快速找到某个桶，这个位置可以被称之为 bucketIndex。可以知道，如果两个对象的hashCode不同，那么equals一定为 false；否则，如果其hashCode相同，equals也不一定为 true。所以，理论上，hashCode 可能存在碰撞的情况，当碰撞发生时，这时会取出bucketIndex桶内已存储的元素，并通过hashCode() 和 equals() 来逐个比较以判断Key是否已存在。如果已存在，则使用新Value值替换旧Value值，并返回旧Value值；如果不存在，则存放新的键值对<key, value="">到桶中。因此，在 HashMap中，equals() 方法只有在哈希码碰撞时才会被用到。</key,></p><p>在 HashMap 中，键值对的存储是通过 put(key,vlaue) 方法来实现的，其源码如下：<br><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> V <span class="hljs-title">put</span>(<span class="hljs-params">K key, V <span class="hljs-keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="hljs-comment">//当key为null时，调用putForNullKey方法，并将该键值对保存到table的第一个位置 </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>)</span><br><span class="line">        <span class="hljs-keyword">return</span> putForNullKey(<span class="hljs-keyword">value</span>); </span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//根据key的hashCode计算hash值</span></span><br><span class="line">    <span class="hljs-keyword">int</span> hash = hash(key.hashCode());             <span class="hljs-comment">//  ------- (1)</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//计算该键值对在数组中的存储位置（哪个桶）</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i = indexFor(hash, table.length);              <span class="hljs-comment">// ------- (2)</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//在table的第i个桶上进行迭代，寻找 key 保存的位置</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;      <span class="hljs-comment">// ------- (3)</span></span><br><span class="line">        Object k;</span><br><span class="line">        <span class="hljs-comment">//判断该条链上是否存在hash值相同且key值相等的映射，若存在，则直接覆盖 value，并返回旧value</span></span><br><span class="line">        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="hljs-keyword">equals</span>(k))) &#123;</span><br><span class="line">            V oldValue = e.<span class="hljs-keyword">value</span>;</span><br><span class="line">            e.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;    <span class="hljs-comment">// 返回旧值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modCount++; <span class="hljs-comment">//修改次数增加1，快速失败机制</span></span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">//原HashMap中无该映射，将该添加至该链的链头</span></span><br><span class="line">    addEntry(hash, key, <span class="hljs-keyword">value</span>, i);            </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上述源码我们可以清楚了解到HashMap保存数据的过程。首先，判断key是否为null，若为null，则直接调用putForNullKey方法；<br><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">private</span> V <span class="hljs-title">putForNullKey</span>(<span class="hljs-params">V <span class="hljs-keyword">value</span></span>)</span> &#123;</span><br><span class="line">    <span class="hljs-comment">// 若key==null，则将其放入table的第一个桶，即 table[0]</span></span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-literal">null</span>; e = e.next) &#123;   </span><br><span class="line">        <span class="hljs-keyword">if</span> (e.key == <span class="hljs-literal">null</span>) &#123;   <span class="hljs-comment">// 若已经存在key为null的键，则替换其值，并返回旧值</span></span><br><span class="line">            V oldValue = e.<span class="hljs-keyword">value</span>;</span><br><span class="line">            e.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;</span><br><span class="line">            e.recordAccess(<span class="hljs-keyword">this</span>);</span><br><span class="line">            <span class="hljs-keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    modCount++;        <span class="hljs-comment">// 快速失败</span></span><br><span class="line">    addEntry(<span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-keyword">value</span>, <span class="hljs-number">0</span>);       <span class="hljs-comment">// 否则，将其添加到 table[0] 的桶中</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过上述源码我们可以清楚知到，HashMap 中可以保存键为NULL的键值对，且该键值对是唯一的。若再次向其中添加键为NULL的键值对，将覆盖其原值。此外，如果HashMap中存在键为NULL的键值对，那么一定在第一个桶中。</p><p>如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，比将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到改单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：<br><figure class="highlight cs hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。    </span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addEntry</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> hash, K key, V <span class="hljs-keyword">value</span>, <span class="hljs-keyword">int</span> bucketIndex</span>)</span> &#123;    </span><br><span class="line">    <span class="hljs-comment">// 保存“bucketIndex”位置的值到“e”中    </span></span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];    </span><br><span class="line">    <span class="hljs-comment">// 设置“bucketIndex”位置的元素为“新Entry”，    </span></span><br><span class="line">    <span class="hljs-comment">// 设置“e”为“新Entry的下一个节点”    </span></span><br><span class="line">    table[bucketIndex] = <span class="hljs-keyword">new</span> Entry&lt;K,V&gt;(hash, key, <span class="hljs-keyword">value</span>, e);    </span><br><span class="line">    <span class="hljs-comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小    </span></span><br><span class="line">    <span class="hljs-keyword">if</span> (size++ &gt;= threshold)    </span><br><span class="line">        resize(<span class="hljs-number">2</span> * table.length);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。<br>两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</p><p>再看源码中的 (3) 处，此处迭代原因就是为了防止存在相同的key值。如果发现两个hash值（key）相同时，HashMap的处理方式是用新value替换旧value，这里并没有处理key，这正好解释了 HashMap 中没有两个相同的 key。</p><h2 id="读取实现"><a href="#读取实现" class="headerlink" title="读取实现"></a>读取实现</h2><p>相对于HashMap的存储而言，读取就显得比较简单了。因为，HashMap只需通过key的hash值定位到table数组的某个特定的桶，然后查找并返回该key对应的value即可，源码如下：<br><figure class="highlight processing hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 获取key对应的value    </span></span><br><span class="line"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;    </span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)    </span><br><span class="line">        <span class="hljs-keyword">return</span> getForNullKey();    </span><br><span class="line">    <span class="hljs-comment">// 获取key的hash值    </span></span><br><span class="line">    <span class="hljs-built_in">int</span> hash = hash(<span class="hljs-built_in">key</span>.hashCode());    </span><br><span class="line">    <span class="hljs-comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素    </span></span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];    </span><br><span class="line">         e != <span class="hljs-keyword">null</span>;    </span><br><span class="line">         e = e.next) &#123;    </span><br><span class="line">        <span class="hljs-keyword">Object</span> k;    </span><br><span class="line">        <span class="hljs-comment">//判断key是否相同  </span></span><br><span class="line">        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.equals(k)))    </span><br><span class="line">            <span class="hljs-keyword">return</span> e.value;    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="hljs-comment">//没找到则返回null  </span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line"><span class="hljs-comment">// 获取“key为null”的元素的值    </span></span><br><span class="line"><span class="hljs-comment">// HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！    </span></span><br><span class="line"><span class="hljs-keyword">private</span> V getForNullKey() &#123;    </span><br><span class="line">    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="hljs-number">0</span>]; e != <span class="hljs-keyword">null</span>; e = e.next) &#123;    </span><br><span class="line">        <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)    </span><br><span class="line">            <span class="hljs-keyword">return</span> e.value;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。<br>如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p><h2 id="关于扩容"><a href="#关于扩容" class="headerlink" title="关于扩容"></a>关于扩容</h2><p>上面我们看到了扩容的方法，resize方法，它的源码如下：<br><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 重新调整HashMap的大小，newCapacity是调整后的单位    </span></span><br><span class="line">void resize(int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>) &#123;    </span><br><span class="line">    Entry[] oldTable = table;    </span><br><span class="line">    int oldCapacity = oldTable.length;    </span><br><span class="line">    <span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;    </span><br><span class="line">        threshold = Integer.MAX_VALUE;    </span><br><span class="line">        <span class="hljs-keyword">return</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  </span><br><span class="line">    <span class="hljs-comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，    </span></span><br><span class="line">    <span class="hljs-comment">// 然后，将“新HashMap”赋值给“旧HashMap”。    </span></span><br><span class="line">    Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Entry</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>];    </span><br><span class="line">    transfer(<span class="hljs-keyword">new</span><span class="hljs-type">Table</span>);    </span><br><span class="line">    table = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>;    </span><br><span class="line">    threshold = (int)(<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> * loadFactor);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>很明显，是新建了一个HashMap的底层数组，而后调用transfer方法，将就HashMap的全部元素添加到新的HashMap中（要重新计算元素在新的数组中的索引位置）。transfer方法的源码如下：</p><figure class="highlight haxe hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 将HashMap中的全部元素都添加到newTable中    </span></span><br><span class="line">void transfer(Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>) &#123;    </span><br><span class="line">    Entry[] src = table;    </span><br><span class="line">    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>.length;    </span><br><span class="line">    <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123;    </span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];    </span><br><span class="line">        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;    </span><br><span class="line">            src[j] = <span class="hljs-literal">null</span>;    </span><br><span class="line">            <span class="hljs-keyword">do</span> &#123;    </span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;    </span><br><span class="line">                int i = indexFor(e.hash, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);    </span><br><span class="line">                e.next = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i];    </span><br><span class="line">                <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i] = e;    </span><br><span class="line">                e = next;    </span><br><span class="line">            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-literal">null</span>);    </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，扩容是一个相当耗时的操作，因为它需要重新计算这些元素在新的数组中的位置并进行复制处理。因此，我们在用HashMap的时，最好能提前预估下HashMap中元素的个数，这样有助于提高HashMap的性能。</p><h2 id="hash算法"><a href="#hash算法" class="headerlink" title="hash算法"></a>hash算法</h2><p>我们重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。<br>计算哈希值的方法如下：<br><figure class="highlight nginx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-attribute">static</span> int hash(int h) &#123;  </span><br><span class="line">        <span class="hljs-attribute">h</span><span class="hljs-regexp"> ^=</span> (h &gt;&gt;&gt; <span class="hljs-number">20</span>)<span class="hljs-regexp"> ^</span> (h &gt;&gt;&gt; <span class="hljs-number">12</span>);  </span><br><span class="line">        <span class="hljs-attribute">return</span> h<span class="hljs-regexp"> ^</span> (h &gt;&gt;&gt; <span class="hljs-number">7</span>)<span class="hljs-regexp"> ^</span> (h &gt;&gt;&gt; <span class="hljs-number">4</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>它只是一个数学公式，IDK这样设计对hash值的计算，自然有它的好处，至于为什么这样设计，我们这里不去追究，只要明白一点，用的位的操作使hash值的计算效率很高。</p><p>由hash值找到对应索引的方法如下：<br><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;  </span><br><span class="line">        <span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>);  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个我们要重点说下，我们一般对哈希表的散列很自然地会想到用hash值对length取模（即除法散列法），Hashtable中也是这样实现的，这种方法基本能保证元素在哈希表中散列的比较均匀，但取模会用到除法运算，效率很低，HashMap中则通过h&amp;(length-1)的方法来代替取模，同样实现了均匀的散列，但效率要高很多，这也是HashMap对Hashtable的一个改进。</p><p>接下来，我们分析下为什么哈希表的容量一定要是2的整数次幂。首先，length为2的整数次幂的话，h&amp;(length-1)就相当于对length取模，这样便保证了散列的均匀，同时也提升了效率；其次，length为2的整数次幂的话，为偶数，这样length-1为奇数，奇数的最后一位是1，这样便保证了h&amp;(length-1)的最后一位可能为0，也可能为1（这取决于h的值），即与后的结果可能为偶数，也可能为奇数，这样便可以保证散列的均匀性，而如果length为奇数的话，很明显length-1为偶数，它的最后一位是0，这样h&amp;(length-1)的最后一位肯定为0，即只能为偶数，这样任何hash值都只会被散列到数组的偶数下标位置上，这便浪费了近一半的空间，因此，length取2的整数次幂，是为了使不同hash值发生碰撞的概率较小，这样就能使元素在哈希表中均匀地散列。</p><h2 id="contains方法"><a href="#contains方法" class="headerlink" title="contains方法"></a>contains方法</h2><p>注意containsKey方法和containsValue方法。前者直接可以通过key的哈希值将搜索范围定位到指定索引对应的链表，而后者要对哈希数组的每个链表进行搜索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap简介&quot;&gt;&lt;a href=&quot;#HashMap简介&quot; class=&quot;headerlink&quot; title=&quot;HashMap简介&quot;&gt;&lt;/a&gt;HashMap简介&lt;/h1&gt;&lt;p&gt;HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="HashMap" scheme="http://mindasoft.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Spring-IOC源码剖析</title>
    <link href="http://mindasoft.com/2018/11/23/Spring/Spring-IOC%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/11/23/Spring/Spring-IOC源码剖析/</id>
    <published>2018-11-23T07:29:37.000Z</published>
    <updated>2018-11-27T07:05:51.377Z</updated>
    
    <content type="html"><![CDATA[<p>虽然现在已经是2018年，我们都用springboot，都用注解了，但spring的核心代码还是 spring 之父 Rod Johnson 在 2001 年写的。所以不影响我们学习spring 的核心。</p><p>我们打开spring-framework 源码。从哪里开始学习呢？回忆一下，我们最初学spring的时候，我们是这样开始的：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">import</span> org.springframework.beans.tests.Person;</span><br><span class="line"><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="hljs-keyword">import</span> org.springframework.context.support.FileSystemXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ApplicationContext ctx = <span class="hljs-keyword">new</span> FileSystemXmlApplicationContext</span><br><span class="line">                (<span class="hljs-string">"spring-beans/src/test/resources/beans.xml"</span>);</span><br><span class="line">        System.out.println(<span class="hljs-string">"number : "</span> + ctx.getBeanDefinitionCount());</span><br><span class="line">        ((Person) ctx.getBean(<span class="hljs-string">"person"</span>)).work();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;虽然现在已经是2018年，我们都用springboot，都用注解了，但spring的核心代码还是 spring 之父 Rod Johnson 在 2001 年写的。所以不影响我们学习spring 的核心。&lt;/p&gt;
&lt;p&gt;我们打开spring-framework 源码。从哪里
      
    
    </summary>
    
      <category term="Spring源码分析" scheme="http://mindasoft.com/categories/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Spring" scheme="http://mindasoft.com/tags/Spring/"/>
    
      <category term="IOC" scheme="http://mindasoft.com/tags/IOC/"/>
    
  </entry>
  
  <entry>
    <title>lambda与函数式</title>
    <link href="http://mindasoft.com/2018/11/13/Java/lambda%E4%B8%8E%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    <id>http://mindasoft.com/2018/11/13/Java/lambda与函数式/</id>
    <published>2018-11-13T14:29:37.000Z</published>
    <updated>2018-11-22T08:28:37.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lambda表达式是Java SE 8才引进的新特性。对于只申明一个函数的接口，它提供了一个简单和简洁的编写方式。</p><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight livescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-params">(参数...)</span> -&gt;</span> &#123; 代码块 &#125;</span><br></pre></td></tr></table></figure><p>有三种格式：<br><figure class="highlight livescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-params">(params)</span> -&gt;</span> expression</span><br><span class="line"><span class="hljs-function"><span class="hljs-params">(params)</span> -&gt;</span> statement</span><br><span class="line"><span class="hljs-function"><span class="hljs-params">(params)</span> -&gt;</span> &#123; statements &#125;</span><br></pre></td></tr></table></figure></p><h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>像Comparator这样的只有一个抽象方法的接口，叫做函数式接口（Functional Interface）。与Comparator类似，其他函数式接口的唯一的抽象方法也可以用lambda来表示。</p><p>我们看一下Comparator的源码，发现其多了一个@FunctionalInterface的注解，用来表明它是一个函数式接口。标记了该注解的接口有且仅有一个抽象方法，否则会报编译错误。</p><p>再看一下其他的仅有一个抽象方法的接口，比如Runnable和Callable，发现也都在Java 8之后加了@FunctionalInterface注解。对于Runnable来说，接口定义如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">@FunctionalInterface</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不难推测，其lambda的写法应该是 () -&gt; { body }，它不接收任何参数，方法体中也无return返回值，用起来像这样：<br><figure class="highlight livescript hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;doSomething();&#125;)</span>;</span></span><br></pre></td></tr></table></figure></p><p>此外，随lambda一同增加的还有一个java.util.function包，其中定义了一些常见的函数式接口的。比如：</p><ul><li>Function，接受一个输入参数，返回一个结果。参数与返回值的类型可以不同，我们之前的map方法内的lambda就是表示这个函数式接口的；</li><li>Consumer，接受一个输入参数并且无返回的操作。比如我们针对数据流的每一个元素进行打印，就可以用基于Consumer的lambda；</li><li>Supplier，无需输入参数，只返回结果。看接口名就知道是发挥了对象工厂的作用；</li><li>Predicate，接受一个输入参数，返回一个布尔值结果。比如我们在对数据流中的元素进行筛选的时候，就可以用基于Predicate的lambda；</li><li>…</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="Runnable-Lambda"><a href="#Runnable-Lambda" class="headerlink" title="Runnable Lambda"></a>Runnable Lambda</h2><p>我们可以使用Lambda表达式写一个Runnable测试程序：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-comment">//匿名内部类</span></span><br><span class="line">        Runnable r1 = <span class="hljs-keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"hello Runnable 1!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//Lambda</span></span><br><span class="line">        Runnable r2 = ()-&gt; System.out.println(<span class="hljs-string">"hello Runnable 2"</span>);</span><br><span class="line"></span><br><span class="line">        r1.run();</span><br><span class="line">        r2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Comparator-Lambda"><a href="#Comparator-Lambda" class="headerlink" title="Comparator Lambda"></a>Comparator Lambda</h2><p>下面是java.util.Comparator的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">enum</span> Gender &#123; MALE, FEMALE &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> String givenName;</span><br><span class="line">    <span class="hljs-keyword">private</span> String surName;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;</span><br><span class="line">    <span class="hljs-keyword">private</span> Gender gender;</span><br><span class="line">    <span class="hljs-keyword">private</span> String eMail;</span><br><span class="line">    <span class="hljs-keyword">private</span> String phone;</span><br><span class="line">    <span class="hljs-keyword">private</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="hljs-keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparatorTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; personList = Person.createShortList();</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//匿名内部类</span></span><br><span class="line">        Collections.sort(personList, <span class="hljs-keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">                <span class="hljs-keyword">return</span> o1.getSurName().compareTo(o2.getSurName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(Person p: personList)&#123;</span><br><span class="line">            p.printName();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">//lambda 1</span></span><br><span class="line">        Collections.sort(personList, (Person o1, Person o2)-&gt;o1.getSurName().compareTo(o2.getSurName()));</span><br><span class="line"></span><br><span class="line">        <span class="hljs-keyword">for</span>(Person p: personList)&#123;</span><br><span class="line">            p.printName();</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="hljs-comment">//lambda 2</span></span><br><span class="line">        Collections.sort(personList, (o1, o2)-&gt;o1.getSurName().compareTo(o2.getSurName()));</span><br><span class="line">        <span class="hljs-keyword">for</span>(Person p: personList)&#123;</span><br><span class="line">            p.printName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的lambda 1和lambda 2中的参数可以看到，我们传入的o1, o2可以不用指定它的类型，编译器能够自动判断。（为什么？java.lang.Comparator接口只有一个方法）</p><h2 id="Listener-Lambda"><a href="#Listener-Lambda" class="headerlink" title="Listener Lambda"></a>Listener Lambda</h2><p>最后，我们再看一下ActionListenter的例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> javax.swing.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.awt.*;</span><br><span class="line"><span class="hljs-keyword">import</span> java.awt.event.ActionEvent;</span><br><span class="line"><span class="hljs-keyword">import</span> java.awt.event.ActionListener;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListenerTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JButton testButton = <span class="hljs-keyword">new</span> JButton(<span class="hljs-string">"button"</span>);</span><br><span class="line">        testButton.addActionListener(<span class="hljs-keyword">new</span> ActionListener() &#123;</span><br><span class="line">            <span class="hljs-meta">@Override</span></span><br><span class="line">            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">actionPerformed</span><span class="hljs-params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="hljs-string">"click button, 匿名内部类"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        testButton.addActionListener(event -&gt; System.out.println(<span class="hljs-string">"click button, lambda"</span>));</span><br><span class="line"></span><br><span class="line">        JFrame frame = <span class="hljs-keyword">new</span> JFrame(<span class="hljs-string">"test"</span>);</span><br><span class="line">        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">        frame.add(testButton, BorderLayout.CENTER);</span><br><span class="line">        frame.pack();</span><br><span class="line">        frame.setVisible(<span class="hljs-keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的程序我们看到，lambda表达式作为一个参数传进方法中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Lambda表达式是Java SE 8才引进的新特性。对于只申明一个函数的接口，它提供了一个简单和简洁的编写方式。&lt;/p&gt;
&lt;h1 id=&quot;
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>符号++的原理</title>
    <link href="http://mindasoft.com/2018/11/08/javase/%E7%AC%A6%E5%8F%B7++%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://mindasoft.com/2018/11/08/javase/符号++的原理/</id>
    <published>2018-11-08T09:29:37.000Z</published>
    <updated>2018-11-23T08:20:49.452Z</updated>
    
    <content type="html"><![CDATA[<p>我们在使用java程序时，会使用带 <strong>i++</strong> 这样一个表达式，那么他的底层原理是什么呢？</p><p>先来看下面这段代码：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerPlusPlusLearning</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer i = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;</span><br><span class="line">            <span class="hljs-keyword">synchronized</span> (i)&#123;</span><br><span class="line">                <span class="hljs-keyword">if</span>(i &lt; <span class="hljs-number">200</span>)&#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                &#125;<span class="hljs-keyword">else</span>&#123;</span><br><span class="line">                    <span class="hljs-keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> IntegerPlusPlusLearning());</span><br><span class="line">        Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> IntegerPlusPlusLearning());</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>期待的运行结果：<br><figure class="highlight lsl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span></span><br><span class="line"><span class="hljs-number">2</span></span><br><span class="line"><span class="hljs-number">3</span></span><br><span class="line">...</span><br><span class="line"><span class="hljs-number">200</span></span><br></pre></td></tr></table></figure></p><p><strong>顺序</strong> 输出 i=1到i=200。可惜，这是<label style="color:red">错误的答案。</label></p><p>它的结果可能会出现无序的，或者重复、缺少的情况。</p><h2 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h2><p>1、 分析编译后的IntegerPlusPlusLearning.class文件，发现 i++ 在虚拟机中的执行原理。</p><p>通过jdk自带的javap命令工具，对IntegerPlusPlusLearning.class 进行分析<br>javap -v IntegerPlusPlusLearning.class</p><p>可以看到输出内容中(如下图)，JVM执行 i++ 的内部逻辑。<br><figure class="highlight dts hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public void run();</span><br><span class="line"><span class="hljs-symbol">  descriptor:</span> ()V</span><br><span class="line"><span class="hljs-symbol">  flags:</span> ACC_PUBLIC</span><br><span class="line"><span class="hljs-symbol">  Code:</span></span><br><span class="line">    stack=<span class="hljs-number">2</span>, locals=<span class="hljs-number">5</span>, args_size=<span class="hljs-number">1</span></span><br><span class="line">       <span class="hljs-number">0</span>: getstatic     <span class="hljs-meta">#2                  <span class="hljs-comment">// Field i:Ljava/lang/Integer;</span></span></span><br><span class="line">       <span class="hljs-number">3</span>: dup</span><br><span class="line">       <span class="hljs-number">4</span>: astore_1</span><br><span class="line">       <span class="hljs-number">5</span>: monitorenter</span><br><span class="line">       <span class="hljs-number">6</span>: getstatic     <span class="hljs-meta">#2                  <span class="hljs-comment">// Field i:Ljava/lang/Integer;</span></span></span><br><span class="line">       <span class="hljs-number">9</span>: invokevirtual <span class="hljs-meta">#3                  <span class="hljs-comment">// Method java/lang/Integer.intValue:()I</span></span></span><br><span class="line">      <span class="hljs-number">12</span>: sipush        <span class="hljs-number">200</span></span><br><span class="line">      <span class="hljs-number">15</span>: if_icmpge     <span class="hljs-number">52</span></span><br><span class="line">      <span class="hljs-number">18</span>: getstatic     <span class="hljs-meta">#2                  <span class="hljs-comment">// Field i:Ljava/lang/Integer;</span></span></span><br><span class="line">      <span class="hljs-number">21</span>: astore_2</span><br><span class="line">      <span class="hljs-number">22</span>: getstatic     <span class="hljs-meta">#2                  <span class="hljs-comment">// Field i:Ljava/lang/Integer;</span></span></span><br><span class="line">      <span class="hljs-number">25</span>: invokevirtual <span class="hljs-meta">#3                  <span class="hljs-comment">// Method java/lang/Integer.intValue:()I</span></span></span><br><span class="line">      <span class="hljs-number">28</span>: iconst_1</span><br><span class="line">      <span class="hljs-number">29</span>: iadd</span><br><span class="line">      <span class="hljs-number">30</span>: invokestatic  <span class="hljs-meta">#4                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span></span><br><span class="line">      <span class="hljs-number">33</span>: dup</span><br><span class="line">      <span class="hljs-number">34</span>: putstatic     <span class="hljs-meta">#2                  <span class="hljs-comment">// Field i:Ljava/lang/Integer;</span></span></span><br><span class="line">      <span class="hljs-number">37</span>: astore_3</span><br><span class="line">      <span class="hljs-number">38</span>: aload_2</span><br><span class="line">      <span class="hljs-number">39</span>: pop</span><br></pre></td></tr></table></figure></p><p>22: getstatic —– 获取i的值，Integer类型。<br>25: invokevirtual —– 这里表示调用了，Integer.intValue<br>29: iadd —– 表示i加1<br>30: invokestatic —– 调用Integer.valueOf<br>34: putstatic —– 赋值 </p><p>这个逻辑，通过代码表达出来就是这句“i = Integer.valueOf(i.intValue() + 1)；”</p><p>2、 查看Integer的源码，当变量i的值发生变化后，发现 Integer.valueOf 每次都是新对象。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/** Integer源码取自jdk1.8 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以最后，代码中 i 变量，是一个Integer对象，当代码中两个线程执行 i++时，<br>实际运行时的 i++ 的实现逻辑是这样的：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = Integer.valueOf(i.intValue() + <span class="hljs-number">1</span>)；</span><br></pre></td></tr></table></figure></p><p>而Integer.valueOf每次是返回一个新的Integer对象，所以，我们的synchronized实际上没有起到你预想中的效果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们在使用java程序时，会使用带 &lt;strong&gt;i++&lt;/strong&gt; 这样一个表达式，那么他的底层原理是什么呢？&lt;/p&gt;
&lt;p&gt;先来看下面这段代码：&lt;br&gt;&lt;figure class=&quot;highlight java hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法</title>
    <link href="http://mindasoft.com/2018/11/06/tools/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>http://mindasoft.com/2018/11/06/tools/markdown语法/</id>
    <published>2018-11-06T05:16:08.000Z</published>
    <updated>2018-11-07T04:35:25.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>1.语法：<br><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="hljs-string">淘宝网</span>](<span class="hljs-link">http://www.taobao.com/</span>)</span><br></pre></td></tr></table></figure></p><p>2.例子：<br><a href="http://www.taobao.com/" target="_blank" rel="noopener">淘宝网</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p>1.语法：<br><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="hljs-string">图片标题</span>](<span class="hljs-link">http://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png</span>)</span><br></pre></td></tr></table></figure></p><p>2.例子：<br><img src="http://mat1.gtimg.com/pingjs/ext2020/qqindex2018/dist/img/qq_logo_2x.png" alt="图片标题"></p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>1.语法：<br><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section"># 一级标题</span></span><br><span class="line"><span class="hljs-section">## 二级标题</span></span><br><span class="line"><span class="hljs-section">### 三级标题</span></span><br><span class="line"><span class="hljs-section">#### 四级标题</span></span><br><span class="line"><span class="hljs-section">##### 五级标题</span></span><br><span class="line"><span class="hljs-section">###### 六级标题</span></span><br></pre></td></tr></table></figure></p><p>tips：几个 # 就是几级标题，最小到六级</p><h2 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-emphasis">*这是斜体*</span></span><br><span class="line"> <span class="hljs-emphasis">*[这是斜体链接](http://www.taobao.com)*</span></span><br><span class="line"> <span class="hljs-emphasis">*斜体,[这是斜体链接](http://www.taobao.com)*</span></span><br><span class="line">tips：斜体和链接可以混用</span><br></pre></td></tr></table></figure><h2 id="为字体加颜色"><a href="#为字体加颜色" class="headerlink" title="为字体加颜色"></a>为字体加颜色</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 这是<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span></span>红色<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>字体</span><br><span class="line"> 这是<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:green"</span>&gt;</span></span>绿色<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>字体</span><br><span class="line"> 这是<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:yellow"</span>&gt;</span></span>黄色<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>字体</span><br><span class="line"> 这是<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:blue"</span>&gt;</span></span>蓝色<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span>字体</span><br><span class="line"><span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:red"</span>&gt;</span></span>tips:修改color为对应的颜色英文字母即可，复杂的颜色不要想了，况且大家也用不到<span class="hljs-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p> 例子：<br>  这是<label style="color:red">红色</label>字体<br>   这是<label style="color:green">绿色</label>字体<br>   这是<label style="color:yellow">黄色</label>字体<br>   这是<label style="color:blue">蓝色</label>字体</p><h2 id="为自体加粗"><a href="#为自体加粗" class="headerlink" title="为自体加粗"></a>为自体加粗</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-strong">**加粗**</span>字体</span><br></pre></td></tr></table></figure><p>例子：</p><p><strong>加粗</strong>字体</p><h2 id="Email"><a href="#Email" class="headerlink" title="Email"></a>Email</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Email:<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">yabing.zyb@alibaba-inc.com</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>例子：</p><p>Email:<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x79;&#97;&#98;&#105;&#110;&#x67;&#x2e;&#x7a;&#121;&#x62;&#64;&#97;&#108;&#x69;&#x62;&#x61;&#x62;&#97;&#45;&#105;&#x6e;&#99;&#46;&#99;&#111;&#109;">&#x79;&#97;&#98;&#105;&#110;&#x67;&#x2e;&#x7a;&#121;&#x62;&#64;&#97;&#108;&#x69;&#x62;&#x61;&#x62;&#97;&#45;&#105;&#x6e;&#99;&#46;&#99;&#111;&#109;</a></p><h2 id="无序排列"><a href="#无序排列" class="headerlink" title="无序排列"></a>无序排列</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-bullet">* </span>list1</span><br><span class="line"><span class="hljs-bullet">* </span>list2</span><br><span class="line"><span class="hljs-bullet">* </span>list3</span><br></pre></td></tr></table></figure><h2 id="有序排列"><a href="#有序排列" class="headerlink" title="有序排列"></a>有序排列</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-bullet">1. </span>list1</span><br><span class="line"><span class="hljs-bullet">2. </span>list2</span><br><span class="line"><span class="hljs-bullet">3. </span>list3</span><br></pre></td></tr></table></figure><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-emphasis">***</span></span><br><span class="line">---</span><br><span class="line"><span class="hljs-bullet">- </span>- - -</span><br></pre></td></tr></table></figure><p> tips: 三种都一样</p><h2 id="内容块"><a href="#内容块" class="headerlink" title="内容块"></a>内容块</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-quote">&gt; 这里的内容在内容块中</span></span><br></pre></td></tr></table></figure><p>例子：</p><blockquote><p>这里的内容在内容块中</p></blockquote><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-code">```java</span></span><br><span class="line"><span class="hljs-code"> public class Demo&#123;</span></span><br><span class="line"><span class="hljs-code">     public static void main(String[] args)</span></span><br><span class="line"><span class="hljs-code">       </span></span><br><span class="line"><span class="hljs-code">    &#125;</span></span><br><span class="line"><span class="hljs-code"> &#125;</span></span><br><span class="line"><span class="hljs-code">```</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;</span><br><span class="line">      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内容框"><a href="#内容框" class="headerlink" title="内容框"></a>内容框</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在上一行内容缩进的基础上再缩进四个空格</span><br></pre></td></tr></table></figure><h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">需要换行<span class="hljs-xml"><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span></span>这是换行后的下一行</span><br></pre></td></tr></table></figure><p>例子：需要换行<br>这是换行后的下一行</p><h2 id="中划线"><a href="#中划线" class="headerlink" title="中划线"></a>中划线</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~中划线~~</span><br></pre></td></tr></table></figure><p>例子：<br><del>中划线</del></p><h2 id="添加脚注"><a href="#添加脚注" class="headerlink" title="添加脚注"></a>添加脚注</h2><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是脚注[^1]</span><br><span class="line">[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">这是脚注说明，会在文章的末尾显示.</span></span><br></pre></td></tr></table></figure><p>这是脚注[^1]<br>[^1]: 这是脚注说明，会在文章的末尾显示.</p><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><p>默认表格：<br><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">------------ | ------------- | ------------</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br><span class="line">Content Cell | Content Cell  | Content Cell</span><br></pre></td></tr></table></figure></p><p>例子：</p><table><thead><tr><th>First Header</th><th>Second Header</th><th>Third Header</th></tr></thead><tbody><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr><tr><td>Content Cell</td><td>Content Cell</td><td>Content Cell</td></tr></tbody></table><p>左右浮动表格：<br><figure class="highlight markdown hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">First Header | Second Header | Third Header</span><br><span class="line">:----------- | :-----------: | -----------:</span><br><span class="line">Left         | Center        | Right</span><br><span class="line">Left         | Center        | Right</span><br></pre></td></tr></table></figure></p><p>例子：</p><table><thead><tr><th style="text-align:left">First Header</th><th style="text-align:center">Second Header</th><th style="text-align:right">Third Header</th></tr></thead><tbody><tr><td style="text-align:left">Left</td><td style="text-align:center">Center</td><td style="text-align:right">Right</td></tr><tr><td style="text-align:left">Left</td><td style="text-align:center">Center</td><td style="text-align:right">Right</td></tr></tbody></table><p>tips:默认向左对齐</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链接&quot;&gt;&lt;a href=&quot;#链接&quot; class=&quot;headerlink&quot; title=&quot;链接&quot;&gt;&lt;/a&gt;链接&lt;/h2&gt;&lt;p&gt;1.语法：&lt;br&gt;&lt;figure class=&quot;highlight markdown hljs&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
    
      <category term="markdown" scheme="http://mindasoft.com/tags/markdown/"/>
    
      <category term="md" scheme="http://mindasoft.com/tags/md/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-Integer源码分析</title>
    <link href="http://mindasoft.com/2018/10/24/javase/Integer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/10/24/javase/Integer源码分析/</id>
    <published>2018-10-24T14:29:37.000Z</published>
    <updated>2018-11-23T08:20:49.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。</p></blockquote><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从类定义中我们可以知道以下几点：</p><ol><li>Integer类不能被继承</li><li>Integer类实现了Comparable接口，所以可以用compareTo进行比较并且Integer对象只能和Integer类型的对象进行比较，不能和其他类型比较（至少调用compareTo方法无法比较）。</li><li>Integer继承了Number类，所以该类可以调用longValue、floatValue、doubleValue等系列方法返回对应的类型的值。</li><li>Numbers实现Serializable接口，所以Integer也支持序列化和反序列化。</li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>Integer类中定义了以下几个私有属性：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1360826667806852920L</span>;</span><br></pre></td></tr></table></figure></p><ol><li>value属性就是Integer对象中真正保存int值的。</li><li>serialVersionUID和序列化有关。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</li></ol><h2 id="公共属性"><a href="#公共属性" class="headerlink" title="公共属性"></a>公共属性</h2><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//值为 （－（2的31次方）） 的常量，它表示 int 类型能够表示的最小值。</span></span><br><span class="line"><span class="hljs-meta">@Native</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>   MIN_VALUE = <span class="hljs-number">0x80000000</span>;</span><br><span class="line"><span class="hljs-comment">//值为 （（2的31次方）－1） 的常量，它表示 int 类型能够表示的最大值。</span></span><br><span class="line"><span class="hljs-meta">@Native</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span>   MAX_VALUE = <span class="hljs-number">0x7fffffff</span>;   </span><br><span class="line"><span class="hljs-comment">//表示基本类型 int 的 Class 实例。</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Class&lt;Integer&gt;  TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="hljs-string">"int"</span>);</span><br><span class="line"><span class="hljs-comment">//用来以二进制补码形式表示 int 值的比特位数。</span></span><br><span class="line"><span class="hljs-meta">@Native</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIZE = <span class="hljs-number">32</span>;</span><br><span class="line"><span class="hljs-comment">//用来以二进制补码形式表示 int 值的字节数。1.8以后才有</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> BYTES = SIZE / Byte.SIZE;</span><br></pre></td></tr></table></figure><p>以上属性可直接使用，因为他们已经定义成publis static fianl能用的时候尽量使用他们，这样不仅能使代码有很好的可读性，也能提高性能节省资源。</p><h1 id="装箱拆箱"><a href="#装箱拆箱" class="headerlink" title="装箱拆箱"></a>装箱拆箱</h1><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerLearning</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="hljs-number">100</span>;</span><br><span class="line">        <span class="hljs-keyword">int</span> i2 = i;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，编译后，我们通过jdk自带的javap命令工具对IntegerLearning.class 进行分析<br>javap -v IntegerLearning.class<br><figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);</span><br><span class="line">    descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      <span class="hljs-built_in">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span></span><br><span class="line">         <span class="hljs-number">0</span>: bipush        <span class="hljs-number">100</span></span><br><span class="line">         <span class="hljs-number">2</span>: invokestatic  #2                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">         <span class="hljs-number">5</span>: astore_1</span><br><span class="line">         <span class="hljs-number">6</span>: aload_1</span><br><span class="line">         <span class="hljs-number">7</span>: invokevirtual #3                  <span class="hljs-comment">// Method java/lang/Integer.intValue:()I</span></span><br><span class="line">        <span class="hljs-number">10</span>: istore_2</span><br><span class="line">        <span class="hljs-number">11</span>: getstatic     #4                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="hljs-number">14</span>: aload_1</span><br><span class="line">        <span class="hljs-number">15</span>: invokevirtual #5                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span></span><br><span class="line">        <span class="hljs-number">18</span>: <span class="hljs-keyword">return</span></span><br></pre></td></tr></table></figure></p><p>从上面可以看出Integer i = 100; 编译器会转成 Integer i = Integer.valueOf(100);<br>int i2 = i 自动拆箱用的是 Integer.intValue</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// high value may be configured by property</span></span><br><span class="line">        <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="hljs-string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">                <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="hljs-number">127</span>);</span><br><span class="line">                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);</span><br><span class="line">            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];</span><br><span class="line">        <span class="hljs-keyword">int</span> j = low;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="hljs-keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Integer内部有一个内部类IntegerCache，用来缓存缓存以支持-128和127（包括）之间的值的自动装箱的对象标识语义。<br>可以看出，Integer实例化时，IntegerCache中的 Integer cache[] 缓存了 -128 和127（包括）之间的值，下面会介绍如何使用了缓存的内部类。</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>Integer提供了两个构造方法：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">//构造一个新分配的 Integer 对象，它表示指定的 int 值。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">//构造一个新分配的 Integer 对象，它表示 String 参数所指示的 int 值。</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Integer</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = parseInt(s, <span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从构造方法中我们可以知道，初始化一个Integer对象的时候只能创建一个十进制的整数。</p><h2 id="String转Integer"><a href="#String转Integer" class="headerlink" title="String转Integer"></a>String转Integer</h2><h3 id="parse方法"><a href="#parse方法" class="headerlink" title="parse方法"></a>parse方法</h3><p>在String的构造方法中，使用了parseInt，我们来看下全部的parse方法<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用进制基数radix（2,8,10,16,27,36）解析字符串S</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> radix)</span></span></span><br><span class="line"><span class="hljs-function">                <span class="hljs-keyword">throws</span> NumberFormatException</span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (s == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">"null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (radix &lt; Character.MIN_RADIX) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="hljs-string">" less than Character.MIN_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (radix &gt; Character.MAX_RADIX) &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">"radix "</span> + radix +</span><br><span class="line">                                        <span class="hljs-string">" greater than Character.MAX_RADIX"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> negative = <span class="hljs-keyword">false</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>, len = s.length();</span><br><span class="line">    <span class="hljs-keyword">int</span> limit = -Integer.MAX_VALUE;</span><br><span class="line">    <span class="hljs-keyword">int</span> multmin;</span><br><span class="line">    <span class="hljs-keyword">int</span> digit;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (len &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">        <span class="hljs-comment">// 判断字符串开通是否以 + - 开头</span></span><br><span class="line">        <span class="hljs-keyword">char</span> firstChar = s.charAt(<span class="hljs-number">0</span>);</span><br><span class="line">        <span class="hljs-keyword">if</span> (firstChar &lt; <span class="hljs-string">'0'</span>) &#123; <span class="hljs-comment">// Possible leading "+" or "-"</span></span><br><span class="line">            <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">                negative = <span class="hljs-keyword">true</span>;</span><br><span class="line">                limit = Integer.MIN_VALUE;</span><br><span class="line">            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstChar != <span class="hljs-string">'+'</span>)</span><br><span class="line">                <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line"></span><br><span class="line">            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-comment">// Cannot have lone "+" or "-"</span></span><br><span class="line">                <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-comment">// 循环遍历字符串每个字符转成相应进制数字</span></span><br><span class="line">        multmin = limit / radix;</span><br><span class="line">        <span class="hljs-keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="hljs-comment">// Accumulating negatively avoids surprises near MAX_VALUE</span></span><br><span class="line">            digit = Character.digit(s.charAt(i++),radix);</span><br><span class="line">            <span class="hljs-keyword">if</span> (digit &lt; <span class="hljs-number">0</span>) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span> (result &lt; multmin) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result *= radix;</span><br><span class="line">            <span class="hljs-keyword">if</span> (result &lt; limit + digit) &#123;</span><br><span class="line">                <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">            &#125;</span><br><span class="line">            result -= digit;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">throw</span> NumberFormatException.forInputString(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> negative ? result : -result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseInt</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> parseInt(s,<span class="hljs-number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseUnsignedInt</span><span class="hljs-params">(String s)</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parseUnsignedInt</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure></p><p>parseUnsignedInt 解析无符号的字符串，在内部原理调用的是parseInt 或者Long.parseLong。这里就不在说明。</p><h3 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a>valueOf方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> radix)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Integer.valueOf(parseInt(s,radix));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> Integer.valueOf(parseInt(s, <span class="hljs-number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>valueOf(int i)使用缓存内部类IntegerCache,<strong>如果是-128和127之间的数，不是重新new的类，而直接返回缓存的Integer类。</strong></p><h3 id="getInteger方法"><a href="#getInteger方法" class="headerlink" title="getInteger方法"></a>getInteger方法</h3><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">getInteger</span><span class="hljs-params">(String nm)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> getInteger(nm, <span class="hljs-keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">getInteger</span><span class="hljs-params">(String nm, <span class="hljs-keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    Integer result = getInteger(nm, <span class="hljs-keyword">null</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> (result == <span class="hljs-keyword">null</span>) ? Integer.valueOf(val) : result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">getInteger</span><span class="hljs-params">(String nm, Integer val)</span> </span>&#123;</span><br><span class="line">    String v = <span class="hljs-keyword">null</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        v = System.getProperty(nm);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException | NullPointerException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">if</span> (v != <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> Integer.decode(v);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出getInteger 实际上调用的是Integer.decode方法。那我们来看看decode<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 通过字符串前面几位字符得出 是否为 十进制，十六进制和八进制数，而以其规则解析成Integer类</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">decode</span><span class="hljs-params">(String nm)</span> <span class="hljs-keyword">throws</span> NumberFormatException </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> radix = <span class="hljs-number">10</span>;</span><br><span class="line">    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">boolean</span> negative = <span class="hljs-keyword">false</span>;</span><br><span class="line">    Integer result;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (nm.length() == <span class="hljs-number">0</span>)</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">"Zero length string"</span>);</span><br><span class="line">    <span class="hljs-keyword">char</span> firstChar = nm.charAt(<span class="hljs-number">0</span>);</span><br><span class="line">    <span class="hljs-comment">// Handle sign, if present</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">'-'</span>) &#123;</span><br><span class="line">        negative = <span class="hljs-keyword">true</span>;</span><br><span class="line">        index++;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (firstChar == <span class="hljs-string">'+'</span>)</span><br><span class="line">        index++;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// Handle radix specifier, if present</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (nm.startsWith(<span class="hljs-string">"0x"</span>, index) || nm.startsWith(<span class="hljs-string">"0X"</span>, index)) &#123;</span><br><span class="line">        index += <span class="hljs-number">2</span>;</span><br><span class="line">        radix = <span class="hljs-number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nm.startsWith(<span class="hljs-string">"#"</span>, index)) &#123;</span><br><span class="line">        index ++;</span><br><span class="line">        radix = <span class="hljs-number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nm.startsWith(<span class="hljs-string">"0"</span>, index) &amp;&amp; nm.length() &gt; <span class="hljs-number">1</span> + index) &#123;</span><br><span class="line">        index ++;</span><br><span class="line">        radix = <span class="hljs-number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (nm.startsWith(<span class="hljs-string">"-"</span>, index) || nm.startsWith(<span class="hljs-string">"+"</span>, index))</span><br><span class="line">        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NumberFormatException(<span class="hljs-string">"Sign character in wrong position"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        result = Integer.valueOf(nm.substring(index), radix);</span><br><span class="line">        result = negative ? Integer.valueOf(-result.intValue()) : result;</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="hljs-comment">// If number is Integer.MIN_VALUE, we'll end up here. The next line</span></span><br><span class="line">        <span class="hljs-comment">// handles this case, and causes any genuine format error to be</span></span><br><span class="line">        <span class="hljs-comment">// rethrown.</span></span><br><span class="line">        String constant = negative ? (<span class="hljs-string">"-"</span> + nm.substring(index))</span><br><span class="line">                                   : nm.substring(index);</span><br><span class="line">        result = Integer.valueOf(constant, radix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们又发现decode 底层调用的是Integer.valueOf。从而得出：</p><p>所有将String转成Integer的方法都是基于parseInt方法实现的。简单看一下以上部分方法的调用栈。<br><figure class="highlight clean hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getInteger(...) ---&gt; ---&gt;Integer.decode(...)---&gt;Integer.valueOf(...)---&gt;parseInt(...)</span><br><span class="line">```           </span><br><span class="line"></span><br><span class="line">## Integer转String</span><br><span class="line"></span><br><span class="line">### toString</span><br></pre></td></tr></table></figure></p><p>public String toString() {<br>    return toString(value);<br>}</p><p>public static String toString(int i) {<br>    if (i == Integer.MIN_VALUE)<br>        return “-2147483648”;<br>    int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i);<br>    char[] buf = new char[size];<br>    getChars(i, size, buf);<br>    return new String(buf, true);<br>}<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>public static String toString(int i, int radix)<br>public static String toBinaryString(int i)<br>public static String toHexString(int i)<br>public static String toOctalString(int i)<br>public static String toUnsignedString(int i)<br>public static String toUnsignedString(int i, int radix)<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="Integer" scheme="http://mindasoft.com/tags/Integer/"/>
    
  </entry>
  
  <entry>
    <title>JavaSE源码分析-String源码分析</title>
    <link href="http://mindasoft.com/2018/10/23/javase/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://mindasoft.com/2018/10/23/javase/String源码分析/</id>
    <published>2018-10-23T10:26:00.000Z</published>
    <updated>2018-11-23T08:20:49.538Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。</p></blockquote><h1 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h1><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>从该类的声明中我们可以看出String是final类型的，表示该类不能被继承，同时该类实现了三个接口：java.io.Serializable、 Comparable<string>、 CharSequence</string></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="私有属性"><a href="#私有属性" class="headerlink" title="私有属性"></a>私有属性</h2><p>Integer类中定义了以下几个私有属性：<br><figure class="highlight aspectj hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> hash;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">-6849794470754667710</span>L;</span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="hljs-keyword">new</span> ObjectStreamField[<span class="hljs-number">0</span>];</span><br></pre></td></tr></table></figure></p><ol><li>value[]这是一个字符数组，并且是final类型，他用于存储字符串内容，从fianl这个关键字中我们可以看出，String的内容一旦被初始化了是不能被更改的。 虽然有这样的例子： String s = “a”; s = “b” 但是，这并不是对s的修改，而是重新指向了新的字符串， 从这里我们也能知道，String其实就是用char[]实现的。</li><li>hash缓存字符串的hash Code，默认值为 0</li><li>因为String实现了Serializable接口，所以支持序列化和反序列化支持。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。</li></ol><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringLearning</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="hljs-string">"abc"</span>;</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"edf"</span>);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码，编译后，我们通过jdk自带的javap命令工具对StringLearning.class 进行分析<br>javap -v StringLearning.class<br><figure class="highlight lasso hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);</span><br><span class="line">  descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    <span class="hljs-built_in">stack</span>=<span class="hljs-number">3</span>, locals=<span class="hljs-number">3</span>, args_size=<span class="hljs-number">1</span></span><br><span class="line">       <span class="hljs-number">0</span>: ldc           #2                  <span class="hljs-comment">// String abc</span></span><br><span class="line">       <span class="hljs-number">2</span>: astore_1</span><br><span class="line">       <span class="hljs-number">3</span>: getstatic     #3                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="hljs-number">6</span>: aload_1</span><br><span class="line">       <span class="hljs-number">7</span>: invokevirtual #4                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="hljs-number">10</span>: <span class="hljs-literal">new</span>           #5                  <span class="hljs-comment">// class java/lang/String</span></span><br><span class="line">      <span class="hljs-number">13</span>: dup</span><br><span class="line">      <span class="hljs-number">14</span>: ldc           #6                  <span class="hljs-comment">// String edf</span></span><br><span class="line">      <span class="hljs-number">16</span>: invokespecial #7                  <span class="hljs-comment">// Method java/lang/String."&lt;init&gt;":(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="hljs-number">19</span>: astore_2</span><br><span class="line">      <span class="hljs-number">20</span>: getstatic     #3                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">      <span class="hljs-number">23</span>: aload_2</span><br><span class="line">      <span class="hljs-number">24</span>: invokevirtual #4                  <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">      <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span></span><br></pre></td></tr></table></figure></p><p>ldc表示将一个常量加载到操作数栈。 #2 从常量池中取出”abc”的引用，加载到操作数栈中 。在编译启动过程中,字符串字面量就会被存入常量池<br>astore_1 保存一个变量，就是s1<br>16: invokespecial #7  是调用String的构造方法。</p><p>由以上可以知道，String s1 = “abc”中s1只是引用了常量池的值。String s2 = new String(“edf”);的s2是指向了一个String对象。<br>那么：<br><figure class="highlight arduino hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">String</span> s1 = <span class="hljs-string">"abc"</span>;</span><br><span class="line"><span class="hljs-keyword">String</span> s2 = <span class="hljs-string">"abc"</span>;</span><br><span class="line"><span class="hljs-keyword">String</span> s3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">"abc"</span>);</span><br><span class="line"><span class="hljs-keyword">String</span> s4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">String</span>(<span class="hljs-string">"abc"</span>);</span><br></pre></td></tr></table></figure></p><p>s1 == s2        答案：true<br>s1 == s3        答案：false<br>s3 == s4        答案：false<br>s1.equals(s2)   答案：true<br>s1.equals(s3)   答案：true<br>s3.equals(s4)   答案：true</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>String类作为一个java.lang包中比较常用的类,自然有很多重载的构造方法.在这里介绍几种典型的构造方法:<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="hljs-keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们知道，其实String就是使用字符数组（char[]）实现的。所以我们可以使用一个字符数组来创建一个String，那么这里值得注意的是，当我们使用字符数组创建String的时候，会用到Arrays.copyOf方法和Arrays.copyOfRange方法。这两个方法是将原有的字符数组中的内容逐一的复制到String中的字符数组中。同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将源String中的value和hash两个属性直接赋值给目标String。因为String一旦定义之后是不可以改变的，所以也就不用担心改变源String的值会影响到目标String的值。</p><p>当然，在使用字符数组来创建一个新的String对象的时候，不仅可以使用整个字符数组，也可以使用字符数组的一部分，只要多传入两个参数int offset和int count就可以了。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(<span class="hljs-keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Java中，String实例中保存有一个char[]字符数组，char[]字符数组是以unicode码来存储的，String 和 char 为内存形式，byte是网络传输或存储的序列化形式。所以在很多传输和存储的过程中需要将byte[]数组和String进行相互转化。所以，String提供了一系列重载的构造方法来将一个字符数组转化成String，提到byte[]和String之间的相互转换就不得不关注编码问题。String(byte[] bytes, Charset charset)是指通过charset来解码指定的byte数组，将其解码成unicode的char[]数组，够造成新的String。</p><p>这里的bytes字节流是使用charset进行编码的，想要将他转换成unicode的char[]数组，而又保证不出现乱码，那就要指定其解码方式</p><p>同样使用字节数组来构造String也有很多种形式，按照是否指定解码方式分的话可以分为两种：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="hljs-keyword">byte</span> bytes[]) String(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span><br><span class="line">String(<span class="hljs-keyword">byte</span> bytes[], Charset charset)</span><br><span class="line">String(<span class="hljs-keyword">byte</span> bytes[], String charsetName)</span><br><span class="line">String(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length, Charset charset)</span><br><span class="line">String(<span class="hljs-keyword">byte</span> bytes[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length, String charsetName)</span><br></pre></td></tr></table></figure></p><p>如果我们在使用byte[]构造String的时候，使用的是下面这四种构造方法(带有charsetName或者charset参数)的一种的话，那么就会使用StringCoding.decode方法进行解码，使用的解码的字符集就是我们指定的charsetName或者charset。 我们在使用byte[]构造String的时候，如果没有指明解码使用的字符集的话，那么StringCoding的decode方法首先调用系统的默认编码格式，如果没有指定编码格式则默认使用ISO-8859-1编码格式进行编码操作。主要体现代码如下：<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] decode(<span class="hljs-keyword">byte</span>[] ba, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len) &#123;</span><br><span class="line">    String csn = Charset.defaultCharset().name();</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// use charset name decode() variant which provides caching.</span></span><br><span class="line">        <span class="hljs-keyword">return</span> decode(csn, ba, off, len);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        warnUnsupportedCharset(csn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> decode(<span class="hljs-string">"ISO-8859-1"</span>, ba, off, len);</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException x) &#123;</span><br><span class="line">        <span class="hljs-comment">// If this code is hit during VM initialization, MessageUtils is</span></span><br><span class="line">        <span class="hljs-comment">// the only way we will be able to get any kind of error message.</span></span><br><span class="line">        MessageUtils.err(<span class="hljs-string">"ISO-8859-1 charset not available: "</span></span><br><span class="line">                         + x.toString());</span><br><span class="line">        <span class="hljs-comment">// If we can not find ISO-8859-1 (a required encoding) then things</span></span><br><span class="line">        <span class="hljs-comment">// are seriously wrong with the installation.</span></span><br><span class="line">        System.exit(<span class="hljs-number">1</span>);</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用StringBuffer和StringBuider构造一个String<br>作为String的两个“兄弟”，StringBuffer和StringBuider也可以被当做构造String的参数。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">String</span><span class="hljs-params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，这两个构造方法是很少用到的，至少我从来没有使用过，因为当我们有了StringBuffer或者StringBuilfer对象之后可以直接使用他们的toString方法来得到String。关于效率问题，Java的官方文档有提到说使用StringBuilder的toString方法会更快一些，原因是StringBuffer的toString方法是synchronized的，在牺牲了效率的情况下保证了线程安全。<br><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(value, <span class="hljs-number">0</span>, count);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br></pre></td></tr></table></figure></p><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Integer 类在对象中包装了一个基本类型 int 的值。Integer 类型的对象包含一个 int 类型的字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;类定义&quot;&gt;&lt;a href=&quot;#类定义&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JavaSE源码分析" scheme="http://mindasoft.com/categories/JavaSE%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="源码分析" scheme="http://mindasoft.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JavaSE" scheme="http://mindasoft.com/tags/JavaSE/"/>
    
      <category term="String" scheme="http://mindasoft.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Linux查看物理CPU个数、核数、逻辑CPU个数</title>
    <link href="http://mindasoft.com/2018/02/07/Linux/Linux%E6%9F%A5%E7%9C%8B%E7%89%A9%E7%90%86CPU%E4%B8%AA%E6%95%B0%E3%80%81%E6%A0%B8%E6%95%B0%E3%80%81%E9%80%BB%E8%BE%91CPU%E4%B8%AA%E6%95%B0/"/>
    <id>http://mindasoft.com/2018/02/07/Linux/Linux查看物理CPU个数、核数、逻辑CPU个数/</id>
    <published>2018-02-07T09:28:52.000Z</published>
    <updated>2018-11-01T11:02:50.207Z</updated>
    
    <content type="html"><![CDATA[<p>CPU总核数 = 物理CPU个数 <em> 每颗物理CPU的核数<br>总逻辑CPU数 = 物理CPU个数 </em> 每颗物理CPU的核数 * 超线程数</p><p>查看CPU信息（型号）<br><figure class="highlight tcl hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@AAA ~]# cat /<span class="hljs-keyword">proc</span>/cpuinfo |<span class="hljs-title"> grep</span> name |<span class="hljs-title"> cut</span> -f2 -d: |<span class="hljs-title"> uniq</span> -c</span><br><span class="line">     24<span class="hljs-title">         Intel(R)</span> Xeon(R)<span class="hljs-title"> CPU</span> E5-2630 0 @ 2.30GHz</span><br><span class="line"></span><br><span class="line"># 查看物理CPU个数</span><br><span class="line">[root@AAA ~]#<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/cpuinfo|<span class="hljs-title"> grep</span> "physical<span class="hljs-title"> id"|</span> sort|<span class="hljs-title"> uniq|</span> wc -l</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"># 查看每个物理CPU中core的个数(即核数)</span><br><span class="line">[root@AAA ~]#<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/cpuinfo|<span class="hljs-title"> grep</span> "cpu<span class="hljs-title"> cores"|</span> uniq</span><br><span class="line">cpu<span class="hljs-title"> cores</span>    : 6</span><br><span class="line"></span><br><span class="line"># 查看逻辑CPU的个数</span><br><span class="line">[root@AAA ~]#<span class="hljs-title"> cat</span> /<span class="hljs-keyword">proc</span>/cpuinfo|<span class="hljs-title"> grep</span> "processor"|<span class="hljs-title"> wc</span> -l</span><br><span class="line">24</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU总核数 = 物理CPU个数 &lt;em&gt; 每颗物理CPU的核数&lt;br&gt;总逻辑CPU数 = 物理CPU个数 &lt;/em&gt; 每颗物理CPU的核数 * 超线程数&lt;/p&gt;
&lt;p&gt;查看CPU信息（型号）&lt;br&gt;&lt;figure class=&quot;highlight tcl hljs&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="Server" scheme="http://mindasoft.com/tags/Server/"/>
    
  </entry>
  
  <entry>
    <title>SSL-https配置</title>
    <link href="http://mindasoft.com/2018/01/08/server/SSL-https%E9%85%8D%E7%BD%AE/"/>
    <id>http://mindasoft.com/2018/01/08/server/SSL-https配置/</id>
    <published>2018-01-08T11:48:52.000Z</published>
    <updated>2018-11-23T01:48:58.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主流证书格式介绍"><a href="#主流证书格式介绍" class="headerlink" title="主流证书格式介绍"></a>主流证书格式介绍</h1><p>一般来说，主流的Web服务软件，通常都基于两种基础密码库：OpenSSL和Java。</p><p>Tomcat、Weblogic、JBoss等，使用Java提供的密码库。通过Java的Keytool工具，生成Java Keystore（JKS）格式的证书文件。</p><p>Apache、Nginx等，使用OpenSSL提供的密码库，生成PEM、KEY、CRT等格式的证书文件。</p><p>BM的产品，如Websphere、IBM Http Server（IHS）等，使用IBM产品自带的iKeyman工具，生成KDB格式的证书文件。</p><p>微软Windows Server中的Internet Information Services（IIS），使用Windows自带的证书库生成PFX格式的证书文件。</p><p>如果您在工作中遇到带有后缀扩展名的证书文件，可以简单用如下方法区分：</p><p><em>.DER </em>.CER : 这样的证书文件是二进制格式，只含有证书信息，不包含私钥。</p><p><em>.CRT : 这样的文件可以是二进制格式，也可以是文本格式，一般均为文本格式，功能与</em>.DER/*.CER相同。</p><p><em>.PEM : 一般是文本格式，可以放证书或私钥，或者两者都包含。 </em>.PEM如果只包含私钥，那一般用 *.KEY代替。</p><p><em>.PFX </em>.P12 是二进制格式，同时含证书和私钥，一般有密码保护。</p><p>怎么判断是文本格式还是二进制？</p><p>用记事本打开，如果是规则的数字字母，如<br>—–BEGIN CERTIFICATE—–<br>MIIE5zCCA8+gAwIBAgIQN+whYc2BgzAogau0dc3PtzANBgkqh……<br>—–END CERTIFICATE—–<br>就是文本的，上面的BEGIN CERTIFICATE，说明这是一个证书<br>如果是—–BEGIN RSA PRIVATE KEY—–，说明这是一个私钥</p><p>这些证书格式之间是可以互相转换的<br><img src="/images/zhengshu.jpg" alt="证书转换"><br>以下提供了一些证书之间的转换方法：</p><ol><li>将JKS转换成PFX</li></ol><p>可以使用Keytool工具，将JKS格式转换为PFX格式。</p><p>keytool -importkeystore -srckeystore D:\server.jks -destkeystore D:\server.pfx -srcstoretype JKS -deststoretype PKCS12</p><ol><li>将PFX转换为JKS</li></ol><p>可以使用Keytool工具，将PFX格式转换为JKS格式。</p><p>keytool -importkeystore -srckeystore D:\server.pfx -destkeystore D:\server.jks -srcstoretype PKCS12 -deststoretype JKS</p><ol><li>将PEM/KEY/CRT转换为PFX</li></ol><p>使用OpenSSL工具，可以将密钥文件KEY和公钥文件CRT转化为PFX文件。</p><p>将密钥文件KEY和公钥文件CRT放到OpenSSL目录下，打开OpenSSL执行以下命令：</p><p>openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt</p><ol><li>将PFX转换为PEM/KEY/CRT</li></ol><p>使用OpenSSL工具，可以将PFX文件转化为密钥文件KEY和公钥文件CRT。</p><p>将PFX文件放到OpenSSL目录下，打开OpenSSL执行以下命令：</p><p>openssl pkcs12 -in server.pfx -nodes -out server.pem</p><p>openssl rsa -in server.pem -out server.key</p><p>openssl x509 -in server.pem -out server.crt</p><p><strong> 请注意 </strong> 此步骤是专用于使用keytool生成私钥和CSR申请证书，并且获取到pem格式证书公钥的情况下做分离私钥使用的，所以在实际部署证书时请使用此步骤分离出来的私钥和申请下来的公钥证书做匹配使用。</p><p>云盾证书服务统一使用 PEM 格式的数字证书文件。</p><h1 id="pem证书转为jks证书"><a href="#pem证书转为jks证书" class="headerlink" title="pem证书转为jks证书"></a>pem证书转为jks证书</h1><p>第一步：pem(需要私钥) 转为 .pfx<br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs12 -export -out server<span class="hljs-selector-class">.pfx</span> -inkey private<span class="hljs-selector-class">.key</span> -<span class="hljs-keyword">in</span> server.pem</span><br></pre></td></tr></table></figure></p><p>第二步：.pfx 转为 .jks<br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importkeystore -srckeystore server<span class="hljs-selector-class">.pfx</span> -destkeystore server<span class="hljs-selector-class">.jks</span> -srcstoretype PKCS12 -deststoretype JKS</span><br></pre></td></tr></table></figure></p><h1 id="tomcat配置"><a href="#tomcat配置" class="headerlink" title="tomcat配置"></a>tomcat配置</h1><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="hljs-attribute">protocol</span>=<span class="hljs-string">"org.apache.coyote.http11.Http11NioProtocol"</span></span><br><span class="line">                  <span class="hljs-attribute">port</span>=<span class="hljs-string">"443"</span> <span class="hljs-attribute">SSLEnabled</span>=<span class="hljs-string">"true"</span></span><br><span class="line">                   <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">"150"</span> <span class="hljs-attribute">scheme</span>=<span class="hljs-string">"https"</span> <span class="hljs-attribute">secure</span>=<span class="hljs-string">"true"</span></span><br><span class="line">               <span class="hljs-attribute">keystoreFile</span>=<span class="hljs-string">"/home/websoft/key/server.jks"</span> <span class="hljs-attribute">keystorePass</span>=<span class="hljs-string">"123456"</span></span><br><span class="line">               <span class="hljs-attribute">clientAuth</span>=<span class="hljs-string">"false"</span> <span class="hljs-attribute">sslProtocol</span>=<span class="hljs-string">"TLS"</span></span><br><span class="line"> <span class="hljs-attribute">ciphers</span>=<span class="hljs-string">"TLS_RSA_WITH_AES_128_CBC_SHA,TLS_RSA_WITH_AES_256_CBC_SHA,TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA,</span></span><br><span class="line"><span class="hljs-string">TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_128_CBC_SHA256,TLS_RSA_WITH_AES_256_CBC_SHA256"</span>  /&gt;</span><br></pre></td></tr></table></figure><h1 id="ngnix配置"><a href="#ngnix配置" class="headerlink" title="ngnix配置"></a>ngnix配置</h1><figure class="highlight nginx hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-section">server</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">listen</span>    <span class="hljs-number">80</span>;</span><br><span class="line">  <span class="hljs-attribute">listen</span>    <span class="hljs-number">443</span> ssl;</span><br><span class="line">  <span class="hljs-comment"># ssl on; #在同一个server&#123;&#125;里配置同时开启http和https时，不需要开启此项！</span></span><br><span class="line">  <span class="hljs-attribute">server_name</span> dev.cmop.mgtv.com;</span><br><span class="line">  <span class="hljs-attribute">root</span>     /home/websoft/nginx/html;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attribute">ssl_certificate</span> <span class="hljs-string">"/home/websoft/key/dev/full_chain.pem"</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_certificate_key</span> <span class="hljs-string">"/home/websoft/key/dev/private.key"</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_protocols</span>  SSLv2 SSLv3 TLSv1;<span class="hljs-comment">#指定密码为openssl支持的格式</span></span><br><span class="line">  <span class="hljs-attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;<span class="hljs-comment">#密码加密方式</span></span><br><span class="line">  <span class="hljs-attribute">ssl_prefer_server_ciphers</span>   <span class="hljs-literal">on</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="hljs-attribute">location</span> / &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;</span><br><span class="line">    <span class="hljs-attribute">location</span> = /40x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;</span><br><span class="line">    <span class="hljs-attribute">location</span> = /50x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">server</span> &#123;</span><br><span class="line">  <span class="hljs-attribute">listen</span>    <span class="hljs-number">80</span>;</span><br><span class="line">  <span class="hljs-attribute">listen</span>    <span class="hljs-number">443</span> ssl;</span><br><span class="line">  <span class="hljs-comment"># ssl on;  #在同一个server&#123;&#125;里配置同时开启http和https时，不需要开启此项！</span></span><br><span class="line">  <span class="hljs-attribute">server_name</span> book.cmop.mgtv.com;</span><br><span class="line">  <span class="hljs-attribute">root</span>     /home/websoft/nginx/html;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-attribute">ssl_certificate</span> <span class="hljs-string">"/home/websoft/key/book/full_chain.pem"</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_certificate_key</span> <span class="hljs-string">"/home/websoft/key/book/private.key"</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;</span><br><span class="line">  <span class="hljs-attribute">ssl_protocols</span>  SSLv2 SSLv3 TLSv1;<span class="hljs-comment">#指定密码为openssl支持的格式</span></span><br><span class="line">  <span class="hljs-attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;<span class="hljs-comment">#密码加密方式</span></span><br><span class="line">  <span class="hljs-attribute">ssl_prefer_server_ciphers</span>   <span class="hljs-literal">on</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="hljs-attribute">location</span> / &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-attribute">error_page</span> <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;</span><br><span class="line">    <span class="hljs-attribute">location</span> = /40x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;</span><br><span class="line">    <span class="hljs-attribute">location</span> = /50x.html &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-section">server</span> &#123;</span><br><span class="line">    <span class="hljs-attribute">listen</span>      <span class="hljs-number">80</span>;</span><br><span class="line">    <span class="hljs-attribute">listen</span>      <span class="hljs-number">443</span> ssl;</span><br><span class="line">    <span class="hljs-attribute">server_name</span>  mango.m.lrts.me;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-attribute">ssl_certificate</span> <span class="hljs-string">"/data/nginx/key/mango.m.lrts.me_bundle.crt"</span>;</span><br><span class="line">    <span class="hljs-attribute">ssl_certificate_key</span> <span class="hljs-string">"/data/nginx/key/mango.m.lrts.me.key"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-attribute">ssl_session_timeout</span> <span class="hljs-number">5m</span>;</span><br><span class="line">    <span class="hljs-attribute">ssl_protocols</span> TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>; <span class="hljs-comment">#启用TLS1.1、TLS1.2要求OpenSSL1.0.1及以上版本，若您的OpenSSL版本低于要求，请使用 ssl_protocols TLSv1;</span></span><br><span class="line">    <span class="hljs-attribute">ssl_ciphers</span> HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUM;</span><br><span class="line">    <span class="hljs-attribute">ssl_prefer_server_ciphers</span> <span class="hljs-literal">on</span>;</span><br><span class="line">    <span class="hljs-attribute">ssl_session_cache</span> shared:SSL:<span class="hljs-number">1m</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-attribute">location</span> / &#123;</span><br><span class="line">       <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;</span><br><span class="line">       <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$remote_addr</span>;</span><br><span class="line">       <span class="hljs-attribute">index</span> index.html;</span><br><span class="line">       <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1:3000/;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;主流证书格式介绍&quot;&gt;&lt;a href=&quot;#主流证书格式介绍&quot; class=&quot;headerlink&quot; title=&quot;主流证书格式介绍&quot;&gt;&lt;/a&gt;主流证书格式介绍&lt;/h1&gt;&lt;p&gt;一般来说，主流的Web服务软件，通常都基于两种基础密码库：OpenSSL和Java。&lt;/p&gt;
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="ssl" scheme="http://mindasoft.com/tags/ssl/"/>
    
      <category term="https" scheme="http://mindasoft.com/tags/https/"/>
    
  </entry>
  
  <entry>
    <title>Linux服务器时间同步</title>
    <link href="http://mindasoft.com/2018/01/03/Linux/Linux%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/"/>
    <id>http://mindasoft.com/2018/01/03/Linux/Linux 服务器时间同步/</id>
    <published>2018-01-03T07:46:00.000Z</published>
    <updated>2018-12-03T06:07:34.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、连网的情况："><a href="#一、连网的情况：" class="headerlink" title="一、连网的情况："></a>一、连网的情况：</h1><p>同步互联网的时间(可自行找一个时间服务器)<br><figure class="highlight stylus hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate ntp1<span class="hljs-selector-class">.aliyun</span><span class="hljs-selector-class">.com</span></span><br></pre></td></tr></table></figure></p><p>如果没有该命令，可以执行一下安装<br><figure class="highlight cmake hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="hljs-keyword">install</span> ntupdate ntp</span><br></pre></td></tr></table></figure></p><h1 id="二、离线情况："><a href="#二、离线情况：" class="headerlink" title="二、离线情况："></a>二、离线情况：</h1><p>以其中一台最接近当前网络时间的服务器作为时间服务器，然后其他机器将时间同步到与该机器一致。<br>1、作为时间服务器的那台机器需要开启ntpd服务，其他机器不用开启，命令如下<br><figure class="highlight crmsh hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service ntpd <span class="hljs-literal">start</span></span><br></pre></td></tr></table></figure></p><p>2、其它机器依次执行同步命令<br><figure class="highlight armasm hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">ntpdate</span> 时间服务器的<span class="hljs-built_in">ip</span></span><br></pre></td></tr></table></figure></p><p> 执行完上述步骤便完成时间同步了。 </p><h1 id="三、配置定时任务同步时间"><a href="#三、配置定时任务同步时间" class="headerlink" title="三、配置定时任务同步时间"></a>三、配置定时任务同步时间</h1><p>建议可以通过配置定时任务定时去同步时间，配置如下<br><figure class="highlight basic hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">0 </span><span class="hljs-number">3</span> * * * /<span class="hljs-keyword">usr</span>/sbin/ntpdate -u ntp1.aliyun.<span class="hljs-keyword">com</span>  ,凌晨<span class="hljs-number">3</span>点</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight basic hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-symbol">0 </span>*/<span class="hljs-number">1</span> * * * /<span class="hljs-keyword">usr</span>/sbin/ntpdate -u ntp1.aliyun.<span class="hljs-keyword">com</span>，每隔<span class="hljs-number">1</span>小时同步一次时间。</span><br></pre></td></tr></table></figure></p><h1 id="四、系统时间同步到硬件，防止系统重启后时间被还原"><a href="#四、系统时间同步到硬件，防止系统重启后时间被还原" class="headerlink" title="四、系统时间同步到硬件，防止系统重启后时间被还原"></a>四、系统时间同步到硬件，防止系统重启后时间被还原</h1><p>hwclock –systohc</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、连网的情况：&quot;&gt;&lt;a href=&quot;#一、连网的情况：&quot; class=&quot;headerlink&quot; title=&quot;一、连网的情况：&quot;&gt;&lt;/a&gt;一、连网的情况：&lt;/h1&gt;&lt;p&gt;同步互联网的时间(可自行找一个时间服务器)&lt;br&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://mindasoft.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux时间和时区</title>
    <link href="http://mindasoft.com/2018/01/03/Linux/Linux%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%B6%E5%8C%BA/"/>
    <id>http://mindasoft.com/2018/01/03/Linux/Linux时间和时区/</id>
    <published>2018-01-03T07:46:00.000Z</published>
    <updated>2018-11-01T11:19:23.590Z</updated>
    
    <content type="html"><![CDATA[<p>如果你的 Linux 系统时区配置不正确，必需要手动调整到正确的当地时区。<br>NTP 对时间的同步处理只计算当地时间与 UTC 时间的偏移量，因此配置一个 NTP 对时间进行同步并不能解决时区不正确的问题。<br>所以大家在用了国外云计算服务商如 Microsoft Azure 或其它 VPS、虚拟机时，需要注意是否与中国大陆的时区一致。</p><h1 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h1><figure class="highlight vala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta"># 查询时间</span></span><br><span class="line">date</span><br><span class="line"><span class="hljs-meta"># 修改时间</span></span><br><span class="line">date -s <span class="hljs-string">"2018-01-03 15:36:25"</span></span><br><span class="line"><span class="hljs-meta"># 查看时区时间</span></span><br><span class="line">ls -l /etc/localtime</span><br></pre></td></tr></table></figure><h1 id="时区"><a href="#时区" class="headerlink" title="时区"></a>时区</h1><p>/etc/localtime是用来描述本机时间，而 /etc/timezone是用来描述本机所属的时区.<br><figure class="highlight vala hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta"># 修改时区</span></span><br><span class="line">tzselect</span><br><span class="line"><span class="hljs-meta"># 查看时区</span></span><br><span class="line">timedatectl</span><br></pre></td></tr></table></figure></p><p>Linux 用户一个多用户系统，每个用户都可以配置自己所需的时区，你可以为自己新增一个 TZ 环境变量：<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">TZ</span>=<span class="hljs-string">'Asia/Shanghai'</span></span><br></pre></td></tr></table></figure></p><p>执行完成之后需要重新登录系统或刷新 ~/.bashrc 生效。<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure></p><p>更改Linux系统时区<br>要更改 Linux 系统整个系统范围的时区可以使用如下命令：<br><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -f <span class="hljs-regexp">/etc/</span>localtime</span><br><span class="line">sudo ln -s <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/zoneinfo/</span>Asia<span class="hljs-regexp">/Shanghai /</span>etc<span class="hljs-regexp">/localtime</span></span><br></pre></td></tr></table></figure></p><p>注意：/usr/share/zoneinfo/Asia/Shanghai 中的具体时区请用自己获取到的 TZ 值进行替换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如果你的 Linux 系统时区配置不正确，必需要手动调整到正确的当地时区。&lt;br&gt;NTP 对时间的同步处理只计算当地时间与 UTC 时间的偏移量，因此配置一个 NTP 对时间进行同步并不能解决时区不正确的问题。&lt;br&gt;所以大家在用了国外云计算服务商如 Microsoft A
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="Linux" scheme="http://mindasoft.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Centos7.3防火墙配置</title>
    <link href="http://mindasoft.com/2018/01/02/Linux/Centos7.3%E9%98%B2%E7%81%AB%E5%A2%99%E9%85%8D%E7%BD%AE/"/>
    <id>http://mindasoft.com/2018/01/02/Linux/Centos7.3防火墙配置/</id>
    <published>2018-01-02T02:02:00.000Z</published>
    <updated>2018-11-20T02:37:30.526Z</updated>
    
    <content type="html"><![CDATA[<h1 id="firewall防火墙"><a href="#firewall防火墙" class="headerlink" title="firewall防火墙"></a>firewall防火墙</h1><p>1、查看firewall服务状态<br><figure class="highlight sql hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">查看状态： systemctl status firewalld </span><br><span class="line">启动： systemctl <span class="hljs-keyword">start</span> firewalld</span><br><span class="line">停止： systemctl <span class="hljs-keyword">stop</span> firewalld</span><br><span class="line">禁用： systemctl <span class="hljs-keyword">enable</span> firewalld</span><br><span class="line">启用： systemctl <span class="hljs-keyword">disable</span> firewalld</span><br><span class="line"></span><br><span class="line">启动一个服务：systemctl <span class="hljs-keyword">start</span> firewalld.service</span><br><span class="line">关闭一个服务：systemctl <span class="hljs-keyword">stop</span> firewalld.service</span><br><span class="line">重启一个服务：systemctl restart firewalld.service</span><br><span class="line">显示一个服务的状态：systemctl <span class="hljs-keyword">status</span> firewalld.service</span><br><span class="line">在开机时启用一个服务：systemctl <span class="hljs-keyword">enable</span> firewalld.service</span><br><span class="line">在开机时禁用一个服务：systemctl <span class="hljs-keyword">disable</span> firewalld.service</span><br><span class="line">查看服务是否开机启动：systemctl <span class="hljs-keyword">is</span>-enabled firewalld.service</span><br><span class="line">查看已启动的服务列表：systemctl <span class="hljs-keyword">list</span>-unit-files|grep enabled</span><br><span class="line">查看启动失败的服务列表：systemctl <span class="hljs-comment">--failed</span></span><br></pre></td></tr></table></figure></p><p>2、查看firewall的状态<br><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-<span class="hljs-keyword">cmd</span><span class="hljs-bash"> --state</span></span><br></pre></td></tr></table></figure></p><p>3、开启、重启、关闭、firewalld.service服务<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="hljs-comment"># 重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="hljs-comment"># 关闭</span></span><br><span class="line">service firewalld stop</span><br></pre></td></tr></table></figure></p><p>4、查看防火墙规则<br><figure class="highlight dockerfile hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">firewall-<span class="hljs-keyword">cmd</span><span class="hljs-bash"> --list-all  -zone=public</span></span><br><span class="line"><span class="hljs-bash"></span></span><br><span class="line"><span class="hljs-bash">查看版本： firewall-cmd --version</span></span><br><span class="line"><span class="hljs-bash">查看帮助： firewall-cmd --<span class="hljs-built_in">help</span></span></span><br><span class="line"><span class="hljs-bash">显示状态： firewall-cmd --state</span></span><br><span class="line"><span class="hljs-bash">查看所有打开的端口： firewall-cmd --zone=public --list-ports</span></span><br><span class="line"><span class="hljs-bash">更新防火墙规则： firewall-cmd --reload</span></span><br><span class="line"><span class="hljs-bash">查看区域信息:  firewall-cmd --get-active-zones</span></span><br><span class="line"><span class="hljs-bash">查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0</span></span><br><span class="line"><span class="hljs-bash">拒绝所有包：firewall-cmd --panic-on</span></span><br><span class="line"><span class="hljs-bash">取消拒绝状态： firewall-cmd --panic-off</span></span><br><span class="line"><span class="hljs-bash">查看是否拒绝： firewall-cmd --query-panic</span></span><br></pre></td></tr></table></figure></p><p>5、查询、开放、关闭端口</p><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查询端口是否开放</span></span><br><span class="line">firewall-cmd <span class="hljs-attribute">--query-port</span>=8080/tcp </span><br><span class="line"><span class="hljs-comment"># 开放80端口</span></span><br><span class="line">firewall-cmd --permanent <span class="hljs-attribute">--add-port</span>=8080/tcp <span class="hljs-attribute">--zone</span>=public</span><br><span class="line"><span class="hljs-comment"># 移除端口</span></span><br><span class="line">firewall-cmd --permanent <span class="hljs-attribute">--remove-port</span>=8080/tcp <span class="hljs-attribute">--zone</span>=public</span><br><span class="line"><span class="hljs-comment">#重启防火墙(修改配置后要重启防火墙)</span></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>参数解释<br>1、firwall-cmd：是Linux提供的操作firewall的一个工具；<br>2、–permanent：表示设置为持久；<br>3、–add-port：标识添加的端口；</p><h1 id="iptables防火墙"><a href="#iptables防火墙" class="headerlink" title="iptables防火墙"></a>iptables防火墙</h1><p>1、安装<br><figure class="highlight smali hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install iptables-services</span><br><span class="line">sudo<span class="hljs-keyword"> system</span>ctl enable iptables &amp;&amp; sudo<span class="hljs-keyword"> system</span>ctl enable ip6tables</span><br><span class="line">sudo<span class="hljs-keyword"> system</span>ctl start iptables &amp;&amp; sudo<span class="hljs-keyword"> system</span>ctl start ip6tables</span><br></pre></td></tr></table></figure></p><p>2、启用、禁用<br><figure class="highlight bash hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="hljs-comment">#最后重启防火墙使配置生效</span></span><br><span class="line">systemctl restart iptables.service</span><br><span class="line"><span class="hljs-comment"># 设置防火墙开机启动</span></span><br><span class="line">systemctl <span class="hljs-built_in">enable</span> iptables.service</span><br></pre></td></tr></table></figure></p><p>3、编辑配置文件<br><figure class="highlight awk hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="hljs-regexp">/etc/</span>sysconfig<span class="hljs-regexp">/iptables</span></span><br></pre></td></tr></table></figure></p><figure class="highlight oxygene hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># sampleconfiguration <span class="hljs-keyword">for</span> iptables service</span><br><span class="line"># you can edit thismanually <span class="hljs-keyword">or</span> use system-config-firewall</span><br><span class="line"># please <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> askus <span class="hljs-keyword">to</span> <span class="hljs-keyword">add</span> additional ports/services <span class="hljs-keyword">to</span> this <span class="hljs-keyword">default</span> configuration</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]</span><br><span class="line">:<span class="hljs-keyword">FORWARD</span> ACCEPT[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]</span><br><span class="line">:OUTPUT ACCEPT[<span class="hljs-number">0</span>:<span class="hljs-number">0</span>]</span><br><span class="line">-A INPUT -m state--state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -jACCEPT</span><br><span class="line">-A INPUT -i lo -jACCEPT</span><br><span class="line">-A INPUT -p tcp -mstate --state <span class="hljs-keyword">NEW</span> -m tcp --dport <span class="hljs-number">22</span> -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state <span class="hljs-keyword">NEW</span> -m tcp --dport <span class="hljs-number">80</span> -jACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state <span class="hljs-keyword">NEW</span> -m tcp --dport <span class="hljs-number">8080</span>-j ACCEPT</span><br><span class="line">-A INPUT -j REJECT--reject-<span class="hljs-keyword">with</span> icmp-host-prohibited</span><br><span class="line">-A <span class="hljs-keyword">FORWARD</span> -jREJECT --reject-<span class="hljs-keyword">with</span> icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>4、开启、停止<br><figure class="highlight routeros hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 查看防火墙状态： </span></span><br><span class="line">service iptables status</span><br><span class="line"><span class="hljs-comment"># 开启防火墙：</span></span><br><span class="line">service iptables start</span><br><span class="line"><span class="hljs-comment"># 关闭防火墙：</span></span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;firewall防火墙&quot;&gt;&lt;a href=&quot;#firewall防火墙&quot; class=&quot;headerlink&quot; title=&quot;firewall防火墙&quot;&gt;&lt;/a&gt;firewall防火墙&lt;/h1&gt;&lt;p&gt;1、查看firewall服务状态&lt;br&gt;&lt;figure class=
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="centos" scheme="http://mindasoft.com/tags/centos/"/>
    
      <category term="防火墙" scheme="http://mindasoft.com/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>Logger4j详解</title>
    <link href="http://mindasoft.com/2017/12/27/Java/Logger4j%E8%AF%A6%E8%A7%A3/"/>
    <id>http://mindasoft.com/2017/12/27/Java/Logger4j详解/</id>
    <published>2017-12-27T05:51:44.000Z</published>
    <updated>2018-11-01T11:19:23.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至是套接口服务 器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式；通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。</p><p>Log4j由三个重要的组件构成：日志信息的优先级（Loggers），日志信息的输出目的地（Appenders），日志信息的输出格式（Layouts）。日志信息的优先级从高到低有ERROR、WARN、 INFO、DEBUG，分别用来指定这条日志信息的重要程度；日志信息的输出目的地指定了日志将打印到控制台还是文件中；而输出格式则控制了日志信息的显示内容。</p><h1 id="二、配置文件"><a href="#二、配置文件" class="headerlink" title="二、配置文件"></a>二、配置文件</h1><p>其实您也可以完全不使用配置文件，而是在代码中配置Log4j环境。但是，使用配置文件将使您的应用程序更加灵活。<br>Log4j支持两种配置文件格式，一种是XML格式的文件，一种是properties格式的文件。下面我们介绍使用properties格式做为配置文件的方法：<br>示例：<br>log4j.rootLogger=INFO, A1<br>log4j.appender.A1=org.apache.log4j.ConsoleAppender<br>log4j.appender.A1.layout=org.apache.log4j.PatternLayout<br>log4j.appender.A1.layout.ConversionPattern=%-4r %-5p [%t] %37c %3x - %m%n</p><h2 id="1-配置根Logger，其语法为："><a href="#1-配置根Logger，其语法为：" class="headerlink" title="1. 配置根Logger，其语法为："></a>1. 配置根Logger，其语法为：</h2><p>log4j.rootLogger = [ level ] , appenderName, appenderName, …<br>其中，level 是日志记录的优先级，分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来。</p><p>appenderName就是指定日志信息输出到哪个地方。您可以同时指定多个输出目的地。</p><h2 id="2-配置日志信息输出目的地Appender，其语法为："><a href="#2-配置日志信息输出目的地Appender，其语法为：" class="headerlink" title="2. 配置日志信息输出目的地Appender，其语法为："></a>2. 配置日志信息输出目的地Appender，其语法为：</h2><p>log4j.appender.appenderName = package+appender_class_name<br>log4j.appender.appenderName.option1 = value1<br>…<br>log4j.appender.appenderName.option = valueN<br>其中，Log4j提供的appender有以下几种：<br>org.apache.log4j.ConsoleAppender（控制台），<br>org.apache.log4j.FileAppender（文件），<br>org.apache.log4j.DailyRollingFileAppender（每天产生一个日志文件），<br>org.apache.log4j.RollingFileAppender（文件大小到达指定尺寸的时候产生一个新的文件），<br>org.apache.log4j.WriterAppender（将日志信息以流格式发送到任意指定的地方)</p><p>org.apache.log4j.jdbc.JDBCAppender(将日志写入数据库)</p><p>(1).ConsoleAppender选项<br>Threshold=WARN:指定日志消息的输出最低层次。<br>ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br>Target=System.err：默认情况下是：System.out,指定输出控制台<br>(2).FileAppender 选项<br>Threshold=WARN:指定日志消息的输出最低层次。<br>ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br>File=mylog.txt:指定消息输出到mylog.txt文件。<br>Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。<br>(3).DailyRollingFileAppender 选项<br>Threshold=WARN:指定日志消息的输出最低层次。<br>ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br>File=mylog.txt:指定消息输出到mylog.txt文件。<br>Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。<br>DatePattern=’.’yyyy-ww:每周滚动一次文件，即每周产生一个新的文件。当然也可以指定按月、周、天、时和分。即对应的格式如下：<br>1)’.’yyyy-MM: 每月<br>2)’.’yyyy-ww: 每周<br>3)’.’yyyy-MM-dd: 每天<br>4)’.’yyyy-MM-dd-a: 每天两次<br>5)’.’yyyy-MM-dd-HH: 每小时<br>6)’.’yyyy-MM-dd-HH-mm: 每分钟<br>(4).RollingFileAppender 选项<br>Threshold=WARN:指定日志消息的输出最低层次。<br>ImmediateFlush=true:默认值是true,意谓着所有的消息都会被立即输出。<br>File=mylog.txt:指定消息输出到mylog.txt文件。<br>Append=false:默认值是true,即将消息增加到指定文件中，false指将消息覆盖指定的文件内容。<br>MaxFileSize=100KB: 后缀可以是KB, MB 或者是 GB. 在日志文件到达该大小时，将会自动滚动，即将原来的内容移到mylog.log.1文件。<br>MaxBackupIndex=2:指定可以产生的滚动文件的最大数。</p><p>(5). JDBCApperder选项</p><p>URL=jdbc:mysql://localhost:3306/test：指定日志写入的数据库链接<br>driver=com.mysql.jdbc.Driver：指定数据库驱动<br>user=root：指定数据库的用户名<br>password=123：指定数据库的登录密码<br>sql=insert into tb_log (message) values(‘=[%-5p] %d(%r) –&gt; [%t] %l: %m %x %n’)：指定写入数据库的执行语句</p><h2 id="3-配置日志信息的布局，其语法为："><a href="#3-配置日志信息的布局，其语法为：" class="headerlink" title="3. 配置日志信息的布局，其语法为："></a>3. 配置日志信息的布局，其语法为：</h2><p>log4j.appender.appenderName.layout = package+layout_class_name<br>log4j.appender.appenderName.layout.option1 = value1<br>…<br>log4j.appender.appenderName.layout.option = valueN<br>其中，Log4j提供的layout有以下几种：<br>org.apache.log4j.HTMLLayout（以HTML表格形式布局），<br>org.apache.log4j.PatternLayout（可以灵活地指定布局模式），<br>org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串），<br>org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息）</p><h2 id="4、输出格式设置"><a href="#4、输出格式设置" class="headerlink" title="4、输出格式设置"></a>4、输出格式设置</h2><p>在配置文件中可以通过log4j.appender.A1.layout.ConversionPattern设置日志输出格式。<br>参数：<br>%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL,<br>%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921</p><p>%r: 输出自应用启动到输出该log信息耗费的毫秒数<br>%c: 输出日志信息所属的类目，通常就是所在类的全名<br>%t: 输出产生该日志事件的线程名<br>%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10)</p><p>%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。<br>%%: 输出一个”%”字符<br>%F: 输出日志消息产生时所在的文件名称<br>%L: 输出代码中的行号<br>%m: 输出代码中指定的消息,产生的日志具体信息<br>%n: 输出一个回车换行符，Windows平台为”\r\n”，Unix平台为”\n”输出日志信息换行<br>可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如：<br>1)%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。<br>2)%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，”-”号指定左对齐。<br>3)%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。<br>4)%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。</p><h1 id="三、如何在不同的模块中输出不同的日志"><a href="#三、如何在不同的模块中输出不同的日志" class="headerlink" title="三、如何在不同的模块中输出不同的日志"></a>三、如何在不同的模块中输出不同的日志</h1><p>用户基础信息模块路径为：com.test.user<br>它下面有个类：com.test.user.service.impl.UserInfo<br>private Log log = LogFactory.getLog(UserInfo.class);</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>在log4j.properties中加入:<br>log4j.logger.com.test.user=info,userLog,stdout<br>log4j.appender.userLog=org.apache.log4j.FileAppender<br>log4j.appender.userLog.File=../logs/userinfo.log<br>log4j.appender.userLog.Append=true<br>log4j.appender.userLog.Threshold=info<br>log4j.appender.userLog.layout=org.apache.log4j.PatternLayout<br>log4j.appender.userLog.layout.ConversionPattern==%d %p [%c] - %m%n</p><p>注：也就是让com.test.user模块下所有的logger使用log4j.appender.userLog所做的配置。</p><h2 id="方法2：自定义“别名”"><a href="#方法2：自定义“别名”" class="headerlink" title="方法2：自定义“别名”"></a>方法2：自定义“别名”</h2><p>private Log log = LogFactory.getLog(“userInfoLog”);<br>然后在log4j.properties中加入:<br>log4j.logger.userInfoLog=info,userLog,stdout<br>log4j.appender.userLog=org.apache.log4j.FileAppender<br>log4j.appender.userLog.File=../logs/userinfo.log<br>log4j.appender.userLog.Append=true<br>log4j.appender.userLog.Threshold=info<br>log4j.appender.userLog.layout=org.apache.log4j.PatternLayout<br>log4j.appender.userLog.layout.ConversionPattern==%d %p [%c] - %m%n</p><p>注：也就是在用logger时给它一个自定义的名字(如这里的”userInfoLog”)，然后在log4j.properties中做出相应配置即可。，在这种模式下，即使在同一个类中也能定义多个不同输出的log.</p><p>在类中调用代码如下：<br>private Log loggerError = LogFactory.getLog(“userErrorLog”);<br>private Log loggerInfo = LogFactory.getLog(“userInfoLog”);</p><p>自定义的日志默认是同时输出到log4j.rootLogger所配置的日志中的，如何能只让它们输出到自己指定的日志中呢？<br>log4j.additivity.userInfoLog = false<br>它用来设置是否同时输出到log4j.rootLogger所配置的日志中，设为false就不会输出到其它地方啦！注意这里的”userInfoLog”是你在程序中给logger起的那个自定义的名字！<br>如果你说，我只是不想同时输出这个日志到log4j.rootLogger所配置的logfile中，stdout里我还想同时输出呢！如：<br>log4j.logger.userInfoLog=DEBUG, userLog, stdout</p><h1 id="三、加载log4j-properties文件"><a href="#三、加载log4j-properties文件" class="headerlink" title="三、加载log4j.properties文件"></a>三、加载log4j.properties文件</h1><h2 id="1、spring方式加载，配置与web-xml中："><a href="#1、spring方式加载，配置与web-xml中：" class="headerlink" title="1、spring方式加载，配置与web.xml中："></a>1、spring方式加载，配置与web.xml中：</h2><p>Spring加载log4j.properties，它提供了一个Log4jConfigListener，本身就能通过web.xml配置从指定位置加载log4j配置文件和log4j的输出路径，要注意的是</p><p>Log4jConfigListener必须要在Spring的Listener之前。</p><p>web.xml<br><figure class="highlight xml hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">&lt;!-- 设置由Spring载入的Log4j配置文件位置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>log4jConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>WEB-INF/classes/log4j.properties<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">&lt;!-- Spring刷新Log4j配置文件变动的间隔,单位为毫秒 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>log4jRefreshInterval<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>10000<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.util.Log4jConfigListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="2、可以通过资源类对资源文件进行加载，与使用为一体"><a href="#2、可以通过资源类对资源文件进行加载，与使用为一体" class="headerlink" title="2、可以通过资源类对资源文件进行加载，与使用为一体"></a>2、可以通过资源类对资源文件进行加载，与使用为一体</h2><figure class="highlight cpp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Logger4JTest</span> &#123;</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        PropertyConfigurator.configure(<span class="hljs-string">" D:/log/log4j.properties "</span>);  </span><br><span class="line">        Logger logger = Logger.getLogger(Logger4JTest.class);  </span><br><span class="line">        logger.debug(<span class="hljs-string">" debug "</span>);  </span><br><span class="line">        logger.error(<span class="hljs-string">" error "</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、在程序中的使用"><a href="#四、在程序中的使用" class="headerlink" title="四、在程序中的使用"></a>四、在程序中的使用</h1><p>在程序中使用Log4j之前，首先要将commons-logging.jar和logging-log4j-1.2.9.jar导入到classpath中，并将log4j.properties放于src根目录中。接下来就可以使用了。</p><h2 id="1-得到记录器"><a href="#1-得到记录器" class="headerlink" title="1.得到记录器"></a>1.得到记录器</h2><p>使用Log4j，第一步就是获取日志记录器，这个记录器将负责控制日志信息。其语法为：<br>public static Logger getLogger( String name)，<br>通过指定的名字获得记录器，如果必要的话，则为这个名字创建一个新的记录器。Name一般取本类的名字，比如：<br>static Logger logger = Logger.getLogger ( ServerWithLog4j.class.getName () ) ; </p><h2 id="2-插入记录信息（格式化日志信息）"><a href="#2-插入记录信息（格式化日志信息）" class="headerlink" title="2.插入记录信息（格式化日志信息）"></a>2.插入记录信息（格式化日志信息）</h2><p>当上两个必要步骤执行完毕，您就可以轻松地使用不同优先级别的日志记录语句插入到您想记录日志的任何地方，其语法如下：<br>logger.debug ( Object message ) ;<br>logger.info ( Object message ) ;<br>logger.warn ( Object message ) ;<br>logger.error ( Object message ) ;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、介绍&quot;&gt;&lt;a href=&quot;#一、介绍&quot; class=&quot;headerlink&quot; title=&quot;一、介绍&quot;&gt;&lt;/a&gt;一、介绍&lt;/h1&gt;&lt;p&gt;Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件、甚至
      
    
    </summary>
    
      <category term="programming" scheme="http://mindasoft.com/categories/programming/"/>
    
    
      <category term="Java" scheme="http://mindasoft.com/tags/Java/"/>
    
  </entry>
  
</feed>
